<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    https://cloud.tencent.com/developer/article/1633898
    <script>
      // requestAnimationFrame更像是微任务之后，宏任务之前
      // console.time("xxx");
      // setTimeout(() => {
      //   console.timeEnd("xxx");
      //   console.log(0);
      // }, 0);
      // let i = 0;
      // console.time("xxx2");
      // requestAnimationFrame(() => console.log(1));
      // setTimeout(() => console.log(2), 20);
      // Promise.resolve(3).then((res) => console.log(res));
      // // requestIdleCallback(() => console.log("idleCallback"));
      // // setTimeout(() => console.log(2), 2000);

      //定时器宏任务可能会直接跳过渲染【requestAnimationFrame，requestAnimationFrame这时候相当于16.7毫秒的定时器了】
      setTimeout(() => {
        requestAnimationFrame(() => console.log("rAF1"));
        console.log("sto1");
      });
      setTimeout(() => {
        requestAnimationFrame(() => console.log("rAF2"));
        console.log("sto2");
      }, 1111); //如果是比较大的时间间隔就正常执行了【sto1,raf1,sto2,raf2】

      queueMicrotask(() => console.log("mic"));
      queueMicrotask(() => console.log("mic"));

      //总结，在同一个宏任务之内，requestAnimationFrame优于其他宏任务先执行，比如前边，但是定时器宏任务内可能会跳过requestAnimationFrame【两个宏任务之间时间太短的话】

      // onbeforeunload不能用window，没法调window【this】上的方法
      // window.onbeforeunload = () => {
      //   alert(111);
      //   return true;
      // };
      window.onbeforeunload = function () {
        console.log("window.onbeforeunload");
        // Blocked prompt alert
        // alert();
        // prompt("是否保存数据");
        return true;
      };
    </script>
  </body>
</html>
