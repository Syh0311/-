## VsCode快捷键

alt+shift+箭头下  向下复制

alt+shift+鼠标下滑   选中滑动的范围



- 1、 ctrl + shift +k **删除行**
- 2、 alt+ shift +↑/↓ **复制行**
- 3、 alt + 光标上下 移动行
- 4、 alt + shift +f 代码格式化
- 5、 alt + shift + I 批量定位到行尾
- 6、 ctrl + u 回到光标上次的位置
- 7、 ctrl + b **打开或关闭侧边栏**
- 8、 ctrl + \ 拆分编辑器
- 9、 ctrl + ~ 或 ctrl + j 打开终端
- 10、 ctrl+k+x 删除多余的空格
- 11、 ctrl+shift+[ 折叠代码
- 12、 ctrl + shift +] 展开代码
- 13、 ctrl + D 局部选择
- 14、 ctrl + shift + L 全局选择
- 15、 ctrl + G 跳转到指定行
- 16、 ctrl + backspace **删除单词**
- 17、 shift + alt +光标拖动 多行选中

解决单文件夹折叠问题：
file ==> preferences ==> settings ==> user ==> Features ==> Explorer ==> Compact Folders 不勾选这个选项即可。

### 插件

1. vue helper：import XX   from xxx  直接出来！！

## 别人的规划

### 两个项目、一段实习经历

### [牛客](https://www.nowcoder.com/discuss/555316?channel=-1&source_id=profile_follow_post_nctrack)

先说一下个人情况，211机械本硕，研二开始自学[前端](https://www.nowcoder.com/jump/super-jump/word?word=前端)，目前拿了[美团](https://www.nowcoder.com/jump/super-jump/word?word=美团)、字节、[百度](https://www.nowcoder.com/jump/super-jump/word?word=百度)offer，[美团](https://www.nowcoder.com/jump/super-jump/word?word=美团)给的薪资还不错（ssp），准备签了

  9月到10月：看黑马pink老师的视频学HTML、CSS、JS，跟着写几个简单页面 

  11月到1月：看王红元老师的Vue视频学Vue，学习数据结构和算法，刷力扣。心理压力过大，身体和精神双重负荷。 

  2月：狂刷力扣 ，看到字节开了一个 前端训练营，投递，但因为入营考试没过，只好作罢。春节期间心情极度压抑，焦虑。 

  3月：狂刷面试题，下一期的字节 [前端]()训练营过了，并做了个 [项目]() 

  4月：面试实习，头铁拿阿里 [腾讯]()练手，结果两个公司流程极快，刚投完就面试了，挂掉。后面稳了稳，面了许多中厂，最后拿了字节和 [美团]()的实习offer。 

  5月：复习总结，准备实习入职 

  6月：实习入职，面试并拿到一个提前批offer 

  7月到8月：实习，并拿到转正

  9月：秋招面试，但由于月初投得晚了，加上实习面评估计不好，没有得到阿里和 [腾讯]()的面试机会

### [知乎]( https://www.zhihu.com/question/23078046/answer/203531074)

##### step1：菜鸟教程JavaScript/w3cschool JavaScript二选其一。

有人说这种教程垃圾，我是不同意的，作为初学者，重要的是先对JS有个初步的理解，看完了能上手做点小东西提升信心。即使抱着效果好一点的高程，也要花上一个月左右看完的吧。这时候前面的知识都忘差不多了，想做个小demo都捉襟见肘。所以，先看这两个在线教程没错。

##### step2：廖雪峰JavaScript教程

廖大教程涵盖内容很广泛，行文流畅而又深入浅出，讲了很多菜鸟和w3c上没有的知识点，基本全是干货，适合这时候看。后面有些章节可以暂时不看，先看三分之二即可。划重点，**map和set，iterable，函数整章，标准对象整章，面向对象编程整章，浏览器整章，jQuery整章**，后面的先别看。然后看第二遍，简单的内容就别看了，回去巩固一下map和set，iterable，map/reduce，filter，sort，闭包，箭头函数，正则表达式，JSON，对象，DOM操作，AJAX，promise，jQuery。时不时做个小demo出来，增强信心。

##### step3：JavaScript高级程序设计（高程、红宝书）

这时候，廖大过了三分之二，有些小细节可能理解了但是又不够扎实，来看高程吧。高程的**4/5/6/7/13是要重点**看的，**8/10/11/12/13是次重点**，第一遍看的时候，和IE有关的都先别看。不要陷入细节，先把大体上的意思理解了。记忆中第一遍看的时候，觉得第4章写的相当不错。

##### step4：菜鸟教程jQuery

建议一天内看完，虽然不敢说自己会jQuery，但是基本就是 $(selection).action()这个套路。

#####  step5：专项突破

到这时，发现简单的内容差不多都理解了，但几块大骨头还是有点生疏，专攻一下this，闭包，原型链，对象，AJAX，JS内存调度，事件处理等自己觉得需要加深理解的地方。

当然，如果你开始就拿出了犀牛书学习，很可能从一开始就“卒”了。

update：

##### step6: 《你不知道的JavaScript》+《深入理解JavaScript》

学JS的同时，也学习一门框架记得。CSS能写页面即可，别研究什么奇技淫巧，浪费时间啊。JS+框架研究6了，工作不愁的。CSS屌顶多是个切图的。

## 规划

3. 

### JavaScript

**1.w3cschool JavaScript       10.09-10.21**

**2.廖雪峰JavaScript教程         10.09-10.21**

​		html+css   10.22-

**3.JavaScript高级程序设计（前七章）**

##### 		ECMAScript 6 入门教程

**4.菜鸟教程jQuery**

**5.你不知道的JavaScript**

#### HTML5、CSS     预计六天

JavaScript高级程序设计（前七章）

vue源码

学习JavaScript数据结构与算法(第3版)

LeetCode

node.js---最低要求是掌握npm、模块加载机制

### [Web 前端怎样入门？ - 知乎](https://www.zhihu.com/question/32314049/answer/100898227) 

##### **2. JavaScript**

这是至关重要的阶段。广义的 JavaScript 可以大致分为语言特性（ECMAScript）和 Web API（DOM、BOM 等）。

- 强烈推荐《JavaScript 高级程序设计（第3版）》，俗称红宝书。前七章大致讲语言特性，是重中之重，必须反复阅读，直至完全理解，有 C/C++ 基础的同学应该没什么问题。DOM、事件流、表单、JSON、Ajax 与最后几章也相当重要，是一些常用的 Web API。其余章节可以略读或直接跳过，比如像 XML 这种已经没用的东西就不用看了，还有那些列举大量 API 的章节，用到再查
- 推荐《JavaScript 语言精粹》，俗称蝴蝶书。超薄的一本，半天就可以看完。JavaScript是一门有很多坑的语言，去掉坑就是“精粹”了，过一遍就好，不理解的以后回头再看。
- ECMAScript(简称 ES) 规范在 2015 年后每年都有新特性加入，而红宝书成书时间较早，很多知识点已经跟不上了。ES6(又称 ES2015) 及以后的语言特性也是必学内容，推荐阮一峰老师的《ES6 标准入门》，但这本书以 API 居多，所以还是留个大致印象，以后写到类似的地方，查一查在新的语言特性下，有没有更简洁的写法就好，不必死记硬背
- 强烈推荐[《你不知道的 JS》](https://github.com/getify/You-Dont-Know-JS)。原版是英文的，有需要的同学可以自行搜索中文版。非常精彩的书，将 JavaScript 的细节一网打尽。前几本书里搞不懂的东西，比如 this 的指向等问题，通常都能在这里找到答案
- 不太推荐《JavaScript权威指南》，也就是犀牛书，那就是像一本字典。我就翻过一下，没有细读，不好进一步评论
- 评论里有提到 jQuery，我觉得完全不用看，写祖传项目的时候再学也很简单的。还是要以原生的 API 为主

以上内容用时 1 个月左右，如果有一些编程经验的话，应该没什么压力。 这些书全部刷完后，差不多就入门了，可以跟人谈笑风生了。 开始实践，IFE2016 阶段二的题基本随便刷。

进阶：

- TypeScript。对于有静态语言经验的同学，可以直接上手，基本没有难度
- 学会使用包管理工具 npm，学会在社区上找想要的包，如 [npms.io](https://npms.io/)
- 尝试使用 webpack 构建项目，并通过 Babel 编译 ES 新特性的代码兼容旧版浏览器。配置 webpack 令人痛苦，先能跑起来就行，精细的优化可以以后慢慢调，多查点资料
- 配置 ESLint 规范代码格式，养成良好编码习惯
- 看一下 lodash，尝试自己用简洁的代码实现。不希望读过我回答的人还遇到下面这种情况，因为这个问题里的面试官我认识（逃

[如何看待前端面试不知道 lodash 被嘲讽不可思议？430 关注 · 118 回答问题](https://www.zhihu.com/question/315141826)

- [Web Fundamentals](https://developers.google.com/web/fundamentals/)，宝藏网站，Web 开发进阶必读

##### **3. JavaScript 框架**

这部分就比较自由了，每个人点的技能树都不一样的。前端的发展是爆炸式的，换工具比翻书还快，所以还是以看文档为主了。

目前主流框架经常被提及的是 React，Angular，Vue。知乎搜一搜就有相当多的优秀答案了。

熟练掌握至少一种框架，把 IFE2016 刷通关吧，耗时 1 个半月左右。我个人推荐 React，对提升 JavaScript 基础有很大帮助。Vue 更像是一门新语言。新人通常不用纠结框架好坏，时间长了都学会也没什么难度吧。

进阶：

- 框架周边生态，如无数种 Redux 封装，无数种 CSS in JS 方案等
- 造些轮子
- 带着问题读源码
- Node.js，Backend for Frontend
- ……
- 都到了这个份上，该学什么心里都有数吧，还用写么

### 刷题-剑指offer

#### [知乎](https://www.zhihu.com/question/271458173/answer/1243628544)

**链表、树->    字符串、数组   ->回溯、动态规划**

我刷题比较功利，针对前端这个岗位的特点，我是这样安排刷题顺序的：

按 tag 刷，先刷数据结构类，频率一天四道，先刷所有链表 easy，如果想了半天没思路就看看题解。看到题解只有**动态规划，回溯**就直接跳过。

再就是刷树的题，树有很多类型，我只刷二叉树和 n 叉树，前端一般不考搜索树，字典树，红黑树等类型的树，还是一天4道 easy 题。

等树的 easy 题刷的差不多了，接下来还是一天四道，每天两道链表 medium，两道树 medium。一般都是先挑一道题，再做相似题，比如先做由前序遍历数列和中序遍历数列构造二叉树，接下来可以做由后序遍历数列和中序遍历数列构造二叉树。

链表和树的题刷的差不多了，接下来就是数组和字符串了。说实话，数组和字符串的题难多了，有些题得用回溯和动态规划来解。还是老规矩先刷几天数组 easy，再刷几天字符串 easy。leetcode 里面最多的就是字符串和数组题了，没必要刷完，分别就刷了三四天吧，我发现瓶颈主要卡在回溯和动态规划，因为我当时压根不太理解这俩算法思想。

然后我就专门开始研究回溯，看了几篇文章，还是 `labuladong `大佬的文章最容易懂，看完就大致明白了回溯的思想和一般套路。去 leetcode 把`排列，子集，组合`类的题目集中刷一遍，回溯暂时告一段落。

接下来开始撸动态规划，到现在我刷题`最怕的还是动态规划题`目前我还只处于能做出一些简单的一维动态规划的题。因为前端动态规划`考的比较少`，最近也不怎么刷。

现在我刷题比较佛系了，就挑一些感觉比较有实际意义或者面试频率特别高的题目刷，链表和树的 hard 还没敢碰。

### 十个网址

\1. 30-seconds-of-code 网站：https://github.com/30-seconds/30-seconds-of-code
\2. 33-js-concepts 网站：https://github.com/leonardomso/33-js-concepts
\3. javascript-questions  网站:https://github.com/lydiahallie/javascript-questions
\4. JavaScript 30  网站：https://github.com/wesbos/JavaScript30
\5. ES6 入门教程 网站：https://es6.ruanyifeng.com/
\6. JavaScript 教程 网站：https://wangdoc.com/javascript/
\7. MDN  网站：https://developer.mozilla.org/zh-CN/
\8. clean-code-javascript 网站：https://github.com/ryanmcdermott/clean-code-javascript
\9. TypeScript 入门教程 网站：https://ts.xcatliu.com
\10. w3school   网站：https://www.w3school.com.cn/js/index.asp

### 锻炼

#### 具体安排

**热身+锻炼+拉伸**

1. 胳膊
2. 背
3. 三角肌
4. 胸
5. 腿【大腿小腿】
6. 腹肌

**三、六：胳膊、三角肌【平举+侧举+拳击】**

**四、七：腿、背【箭步蹲+哑铃划船】**

**五、一：胸、腹肌【俯卧撑+撑】**

![image-20211103204552460](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211103204552460.png)

稍微具体的

![image-20211103205228759](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211103205228759.png)

#### 蛋白质需求

蛋白质：**70*1.7 = 119g**

热量：**2000大卡**



肉 一斤 100g

鸡蛋蛋白**4g左右**蛋白质

07:30 鸡蛋8g+奶8g+黄瓜+面包（未知）+肉（100g） = 16g

10:00 水果

12:00 中午 食堂 一荤两素 20g or 自己带？

15:00 水果

18:00 奶8g+肉+西红柿

牛肉、猪肉、虾、鱼、鸡肉、鸡心









## 项目

- win10套娃网易云、小游戏【前端编程游戏】、浏览器、千万不要点击.exe【永远点不到x的广告】、exe安装、内部notepad【写网页说明】
- 网页时间消耗统计、可视化分析【输入自定义网址、网址词云等、网站打开次数、单次最大时长、保存页面、f番茄功能（倒计时、短暂休息、长时间休息）、网页域名二级菜单】

前端项目去网上找豆瓣和网易的api自己使用vue或者react再或者小程序照着别人的设计搞一遍开发一遍

### 项目开发步骤

接口：http://152.136.185.210:7878/api/hy66

1. 目录结构【comp】
2. css统一性规范【normalize】
3. vueconfig.js  .editorconfig 【配置别名等】

### 项目中遇到得问题

生命后期、路由守护的应用、keep-alvie-[p117](https://www.bilibili.com/video/BV15741177Eh?p=117&spm_id_from=pageDriver)

1. why项目中首页获取数据的re-render；【why项目的第一个分支，数据要用到了才会re-render】

2. 课题组项目封装DragDiv.vue时选择元素使用document.queryseletor('calssName')，导致组件不能复用，why项目中[封装scroll](https://www.bilibili.com/video/BV15741177Eh?p=168&t=513.8)；【1、ref如果是绑定在`组件`中的,那么通过this.$refs.refname获取到的是一个组件对象.ref果是绑定在普通的`元素`中,那么通过this.$refs.refname获取到的是一个元素对象2、避免使用vue操作dom，Vue官方`不推荐直接操作dom`】

3. why中返回到顶部组件，组件不能直接添加事件！！，得用【`@click.native`v-on的修饰符-`ppt-基础语法P27`-vue-cli4好像不用加了？？？（vue3.0+删除.native修饰符了？？？）】

4. 平时发现的小问题：vue中let没有TDZ   【Vue中TDZ问题.vue】

   ```
   <template>
     <div class="">
       <button type="" @click="test">sss</button>
     </div>
   </template>
   <script>
   export default {
     mounted() {
       window.test2 = this.test;
     },
     methods: {
       test() {
         "use strict";
         console.log(scope);    //undefined
         let scope = "local";
         console.log(scope);    //"local"
       },
     },
   };
   </script>
   <style scoped></style>
   
   ```

5. vue中数组问题
   用数组的[true,false,false]当作组件的v-if，`直接修改arr[0] = false;无效`；因为此时并没有出发vue的数据双向绑定机制【待加强！！！】





## D1 10.09

### let for循环

`for`循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。【如果子作用域中没设置i，就去父作用域中找，也就是设置循环变量的作用域！！！】

```javascript
for (let i = 0; i < 3; i++) {
  let i = 'abc'; //子作用域中不声明的话去父作用域中找！！！
  console.log(i);
}
// abc
// abc
// abc
```

上面代码正确运行，输出了 3 次`abc`。这表明函数内部的变量`i`与循环变量`i`不在同一个作用域，有各自单独的作用域（**同一个作用域不可使用 `let` 重复声明同一个变量**）。

### 变量提升（hoist）

var可以在变量声明之前使用   //undefined   即变量存在，但是没有值

let   报|引用错误    //报错ReferenceError

### 暂时性死区（temporal dead zone，TDZ）

**TDZ只针对let**

只要**块级作用域**内存在`let`命令，它所声明的变量就“绑定”（binding）这个区域，**不再受外部的影响**。【上边的**let for循环**就是一个例子】

```javascript
var tmp = 123;

if (true) {
  tmp = 'abc'; // ReferenceError 底层还是先大致过了下块级作用域【编译过程】，发现下边有【let tmp】，所以ReferenceError【let 未声明先调用】
  let tmp;
  console.log(tmp) //Cannot access 'tmp' before initialization
}
```

```
如果变量没声明就打印是【is not defined】
```

有些“死区”比较隐蔽，不太容易发现。

```javascript
function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
```

上面代码中，调用`bar`函数之所以报错（某些实现可能不报错），是因为参数`x`默认值等于另一个参数`y`，而此时`y`还没有声明，属于“死区”。如果`y`的默认值是`x`，就不会报错，因为此时`x`已经声明了。

```javascript
function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```



### ES5 只有全局作用域和函数作用域，没有块级作用域

#### var

```javascript
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = 'hello world';    //different
  }
}

f(); 
```

#### **`let`实际上为 JavaScript 新增了块级作用域**。

块级作用域的出现，实际上使得获得广泛应用的**匿名立即执行函数表达式**（匿名 IIFE）不再必要了。

```javascript
var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    let tmp = 'hello world';    //different
  }
}

f(); 
```

考虑到环境导致的行为差异太大，应该**避免在块级作用域内声明函数**。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

#### const

`const`的作用域与`let`命令相同：只在声明所在的**块级作用域内有效**。



`const`命令声明的常量也是不提升，同样**存在暂时性死区**，只能在声明的位置后面使用。



`const`声明的常量，也与`let`一样**不可重复声明**。



常量`foo`储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把`foo`指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。

```javascript
const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: "foo" is read-only
```

### var、let、const

#### 区别

1. var存在变量提升，即可以在未声明前调用；
2. let/const**【TDZ】**：声明的变量会**产生块级作用域**，如果变量在当前作用域中被创建之前被创建出来，由于此时还未完成语法绑定，如果我们访问或使用该变量,，就会产生暂时性死区的问题【也就是说let/const不存在变量提升，因为直接ReferenceError了】
3. let\const不允许在同一个块级作用域中声明同一个变量【var可以】
4. const声明后**必须要赋值**
4. `let`没有给`顶层对象`中（浏览器是window）添加属性

```js
//1.var可以重复声明
var a = 1;
var a = 2;
console.log(a)  //2

let aa = 1;
let aa = 2;
console.log(a)  //Identifier 'aa' has already been declared

const tmp = new Date();
var tmp = 'new Date()';
console.log(tmp) //Identifier 'tmp' has already been declared

//5.let不给顶层对象【window】添加属性【chrome控制台中！！】

//5.1  let
let a = 'syh'  
window.a   //undefined

//5.2  var
let b = 'sy'  
window.b  //'sy'
```

4、let声明的变量不在全局变量【window】中【**ES6 规定**：为了保持兼容性，`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。】

```js
let num = 111
console.log(this.num); //undefined

var num = 111
console.log(this.num); //111
```

5、let/const只在块级作用域中作用，详细见下边例子：

```js
  var tmp = 'new Date()';

  function f() {
      console.log(tmp);
      if (true) {
          let tmp = 'hello world'; //new Date()    【因为let只只只只只绑定块级作用域，块级作用域外失效，所以可以正常打印出Data，但是tmp是全局的，再次声明后顶替了之前的】
          // var tmp = 'hello world'; //undefined,因为变量提升（hoist）了
      }
  }

  f();
```

#### const注意

`const`实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于**简单类型**的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。

但**对于复合类型**的数据（主要是对象和数组），**变量指向的内存地址**，保存的只是**一个指向实际数据的指针**，`const`只能保证这个指针是固定的（即**总是指向另一个固定的地址**），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。

### Object.freeze

如果真的想将对象冻结，应该使用`Object.freeze`方法。

```javascript
const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
```

上面代码中，常量`foo`指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。

### ES6 声明变量的六种方法

ES5 只有两种声明变量的方法：`var`命令和`function`命令。ES6 除了添加`let`和`const`命令，后面章节还会提到，另外两种声明变量的方法：`import`命令和`class`命令。所以，ES6 一共有 6 种声明变量的方法。

### 顶层对象与全局变量

顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，`window`对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。

ES6 为了改变这一点，一方面规定，为了保持兼容性，**`var`命令和`function`命令声明的全局变量，依旧是顶层对象的属性**；另一方面规定，**`let`命令、`const`命令、`class`命令声明的全局变量，不属于顶层对象的属性**。也就是说，从 ES6 开始，**全局变量将逐步与顶层对象的属性脱钩**。

### globalThis 对象

综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。

```javascript
// 方法一
(typeof window !== 'undefined'
   ? window
   : (typeof process === 'object' &&
      typeof require === 'function' &&
      typeof global === 'object')
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== 'undefined') { return self; }
  if (typeof window !== 'undefined') { return window; }
  if (typeof global !== 'undefined') { return global; }
  throw new Error('unable to locate global object');
};
```

### 解构赋值

#### 对象的解构赋值

如果变量名与属性名不一致，必须写成下面这样。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"

let obj = { first: 'hello', last: 'world' };
let { first: f, last: l } = obj;
f // 'hello'
l // 'world'
```

这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。

```javascript
let { foo: foo, bar: bar } = { foo: 'aaa', bar: 'bbb' };
```

也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。

```javascript
let { foo: baz } = { foo: 'aaa', bar: 'bbb' };
baz // "aaa"
foo // error: foo is not defined
```

上面代码中，`foo`是匹配的模式，`baz`才是变量。真正被赋值的是变量`baz`，而不是模式`foo`。

#### 数组的解构赋值

不常用，因为数组可以直接index获取--但是`可以在声明变量时候使用，便于理解`

**可嵌套**

```
let [a, [[b], c]] = [1, [[2], 3]]; 
// a = 1 
// b = 2 
// c = 3
```

**可忽略**

```
let [a, , b] = [1, 2, 3]; 
// a = 1 
// b = 3
```

**不完全解构**

```
let [a = 1, b] = []; 
// a = 1, b = undefined
```

**剩余运算符**

```
let [a, ...b] = [1, 2, 3]; 
//a = 1 
//b = [2, 3]
```

**解构默认值**

let [a = 2] = [undefined]; // a = 2

## D2 10.14

### ES6的Set和[Map](https://es6.ruanyifeng.com/#docs/set-map#Map)数据结构

Set和Map主要的应用场景在于**数组去重**和**数据存储**，

Set是一种叫做**集合**的数据结构，Map是一种叫做**字典**的数据结构



#### Map遍历方法

Map 结构原生提供三个遍历器生成函数和一个遍历方法。

- `Map.prototype.keys()`：返回键名的遍历器。

- `Map.prototype.values()`：返回键值的遍历器。

- `Map.prototype.entries()`：返回所有成员的遍历器。

- `Map.prototype.forEach()`：遍历 Map 的所有成员。 
  //map.forEach((`value,key,Map`)=>{},thisArg)
  forEach可接受第二个参数|||数组的forEach也可以--用处如下--可借用外部函数处理map中数据

  ```js
  const reporter = {
    report: function(key, value) {
      console.log("Key: %s, Value: %s", key, value);
    }
  };
  
  map.forEach(function(value, key, map) {
    this.report(key, value);
  }, reporter);
  ```

  

#### Map与其他数据结构的互相转换

**（1）Map 转为数组**

前面已经提过，Map 转为数组最方便的方法，就是使用`扩展运算符`（`...`）。

```javascript
const myMap = new Map()
  .set(true, 7)
  .set({foo: 3}, ['abc']);
[...myMap]
// [ [ true, 7 ], [ { foo: 3 }, [ 'abc' ] ] ]
```

**（2）数组 转为 Map**

将数组传入 Map 构造函数，就可以转为 Map。

```javascript
new Map([
  [true, 7],
  [{foo: 3}, ['abc']]
])
// Map {
//   true => 7,
//   Object {foo: 3} => ['abc']
// }
```

**（3）Map 转为对象--Obj**

如果所有 Map 的键都是字符串，它可以无损地转为对象。

```javascript
function strMapToObj(strMap) {
  //let obj = Object.create(null);
  let obj = {};
  for (let [k,v] of strMap) {
    obj[k] = v;
  }
  return obj;
}

const myMap = new Map()
  .set('yes', true)
  .set('no', false);
strMapToObj(myMap)
// { yes: true, no: false }
```

如果有非字符串的键名，那么这个键名会被转成字符串，再作为对象的键名。

法二：使用对象新增方法--[`Object.fromEntries`]()--将一个键值对数组转为对象。

```js
const entries = new Map([
  ['foo', 'bar'],
  ['baz', 42]
]);

Object.fromEntries(entries)
// { foo: "bar", baz: 42 }
```

**（4）对象转为 Map**

对象转为 Map 可以通过`Object.entries()`【包含obj中键值对的二维数组--等于是把数组转化为Map了】

```javascript
let obj = {"a":1, "b":2};
let map = new Map(Object.entries(obj));
//Object.entries(obj)其实就是包含obj中键值对的二维数组
```

此外，也可以自己实现一个转换函数。【同样需要使用`Object.keys`】

```javascript
function objToStrMap(obj) {
  let strMap = new Map();
  for (let k of Object.keys(obj)) {
    strMap.set(k, obj[k]);
  }
  return strMap;
}

objToStrMap({yes: true, no: false})
// Map {"yes" => true, "no" => false}
```

**（5）Map 转为 JSON**

Map 转为 JSON 要区分两种情况。一种情况是，Map 的键名都是字符串，这时可以选择转为对象 JSON。

```javascript
function strMapToJson(strMap) {
  return JSON.stringify(strMapToObj(strMap));//先转化为Obj对象，再将obj对象转为json字符串
}

let myMap = new Map().set('yes', true).set('no', false);
let jsonContent = strMapToJson(myMap)
// '{"yes":true,"no":false}'
```

另一种情况是，Map 的键名有非字符串，这时可以选择转为数组 JSON。

```javascript
function mapToArrayJson(map) {
  return JSON.stringify([...map]);
}

let myMap = new Map().set(true, 7).set({foo: 3}, ['abc']);
mapToArrayJson(myMap)
// '[[true,7],[{"foo":3},["abc"]]]'
```

**（6）JSON 转为 Map**

JSON 转为 Map，正常情况下，所有键名都是字符串。

```javascript
function jsonToStrMap(jsonStr) {
  return objToStrMap(JSON.parse(jsonStr));
}

jsonToStrMap('{"yes": true, "no": false}')
// Map {'yes' => true, 'no' => false}
```

但是，有一种特殊情况，整个 JSON 就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为 Map。这往往是 Map 转为数组 JSON 的逆操作。

```javascript
function jsonToMap(jsonStr) {
  return new Map(JSON.parse(jsonStr));
}

jsonToMap('[[true,7],[{"foo":3},["abc"]]]')
// Map {true => 7, Object {foo: 3} => ['abc']}
```

#### JavaScript 对象和 Map 

|        | 对象                         | Map                      |
| :----- | :--------------------------- | :----------------------- |
| Size   | 对象没有 size 属性           | Maps 有 size 属性        |
| 键类型 | 对象键必须是字符串（或符号） | Map 键可以是任何数据类型 |
| 键顺序 | 对象键没有很好地排序         | Map 键按插入排序         |
| 默认   | 对象有默认键                 | Map 没有默认键           |

#### set集合

```
const s = new Set();

[2, 3, 5, 4, 5, 2, 2].forEach(x => s.add(x));

for (let i of s) {
  console.log(i);
}
// 2 3 5 4

//或者直接新建时候就加数组【即接受数组（或可iterable的对象）作为参数】
const set = new Set([1, 2, 3, 4, 4]);
[...set]
// [1, 2, 3, 4]
```

### 扩展运算符...

作用：将一个数组转为用逗号分隔的参数序列

```js
const set = new Set([1, 2, 3, 4, 4]);
...set    //等于是把括号给去了
```

#### [扩展运算符的应用](https://es6.ruanyifeng.com/?search=%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6&x=0&y=0#docs/array#%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%BA%94%E7%94%A8)



#### 替代函数的 apply 方法

由于扩展运算符可以展开数组，所以不再需要`apply`方法，将数组转为函数的参数了。

#### 通过push函数，将一个数组添加到另一个数组的尾部

```js
// ES5的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);  //高级!!!，等于对arr1进行push，push内容为arr2中元素。

//[].push.apply(arr1, arr2)  //效果一样，关键是把push弄出来【然后让arr1当push函数的thisArg】
```

```js
// ES6的写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
arr1.push(...arr2);  //更高级，此处不能直接push(arr2),直接push是把整个数组作为一个元素传入
```

### 标签模板-标签函数

#### 关联函数的arguments-关联 函数的rest parameters

“标签模板”的一个重要应用，就是**过滤 HTML 字符串，防止用户输入恶意内容**。

标签模板的另一个应用，就是多语言转换（国际化处理）

```javascript
alert`hello`
// 等同于
alert(['hello'])

```

```javascript
let total = 30;
let msg = YhPassthru `The total is ${total} (${total*1.05} with tax)`;

//function YhPassthru(literals,arguments) {
function YhPassthru(literals,...rest) {
    console.log(literals);  //literals是模板字符串中文字部分
    console.log(arguments); //这个arguments是模板字符串变量部分【[${total},${total*1.05}]】，但是怎么关联进来的？？？【设定如此？？？】
    //arguments等于是  ...rest  ,此处最好用...rest【剩余操作符】因为参数数量不确定  高程-P42
    let result = '';
    let i = 0;

    while (i < literals.length) {
        result += literals[i++];
        if (i < arguments.length) {
            result += arguments[i];
        }
    }

    return result;
}
console.log(msg); // "The total is 30 (31.5 with tax)"
```

`passthru`函数采用 rest 参数的写法如下。

```javascript
function passthru(literals, ...values) {
  let output = "";
  let index;
  for (index = 0; index < values.length; index++) {
    output += literals[index] + values[index];
  }

  output += literals[index]
  return output;
}
```

#### Arguments 对象

**`arguments`** 是一个对应于传递给函数的参数的类数组对象。

```js
function func1(a, b, c) {
  console.log(arguments[0]);
  // expected output: 1

  console.log(arguments[1]);
  // expected output: 2

  console.log(arguments[2]);
  // expected output: 3
}

func1(1, 2, 3);

```

**Note**: If you're writing ES6 compatible code, then rest parameters  should be preferred.

#### [rest parameters](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters)

**剩余参数**语法允许我们将一个不定数量的参数表示为一个数组。【`扩展运算符...`的逆运算】

```js
function(a, b, ...theArgs) {
  // ...
}
```

```js
// 配合高阶函数
function sum(...theArgs) {
  return theArgs.reduce((previous, current) => {
    return previous + current;
  });
}

console.log(sum(1, 2, 3));
// expected output: 6

console.log(sum(1, 2, 3, 4));
// expected output: 10

```

#### [`rest parameters`和 `arguments`对象的区别](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Rest_parameters#剩余参数和_arguments对象的区别)

剩余参数和 `arguments`对象之间的区别主要有三个：

- 剩余参数只包含那些没有对应形参的实参，而 `arguments` 对象包含了传给函数的所有实参。
- `arguments`对象不是一个真正的数组，而剩余参数是真正的 `Array`实例，也就是说你能够在它上面直接使用所有的数组方法，比如 `sort`，`map`，`forEach`或`pop`。
- `arguments`对象还有一些附加的属性 （如`callee`属性）。

### 闭包(closure)【关联-作用域链】  

ES5不支持闭包，**ES6才支持闭包**

一个函数和对其周围状态（**lexical environment，词法环境**）的引用捆绑在一起（或者说**函数被引用包围**），这样的组合就是**闭包**（**closure**）。



在一个函数中定义另一个会使闭包变得更加复杂。例如：

```javascript
var iBaseNum = 10;

function addNum(iNum1, iNum2) {
  console.log(arguments.length);  //2
  function doAdd() {
    console.log(arguments.length);//0
    console.log(iNum1 + iNum2 + iBaseNum);
  }
  return doAdd();
}
addNum(1, 2)  // 13
```

这里，函数 addNum() 包括函数 doAdd() （闭包）。内部函数是一个闭包，因为它将获取外部函数的参数 iNum1 和 iNum2 以及全局变量 iBaseNum 的值。 addNum() 的最后一步调用了 doAdd()，把两个参数和全局变量相加，并返回它们的和。

这里要掌握的重要概念是，**doAdd() 函数没有接受参数，它使用的值是从执行环境中获取的**。

可以看到，闭包是 ECMAScript 中非常强大多用的一部分，可用于执行复杂的计算。

### 字符串方法



#### 查

#### endsWith()

`endsWith()`方法用来判断当前字符串是否是以另外一个给定的子字符串“结尾”的，根据判断结果返回 `true` 或 `false`。

可以用于**判断上传文件**

#### indexOf() 

搜索具体的内容，**返回第一个的索引**

#### search()

search() 方法在字符串中搜索指定值并返回匹配的位置，**返回第一个的索引**

#### match()

match() 方法根据正则表达式在字符串中搜索匹配项，并**将匹配项作为 Array 对象返回**。

在字符串中搜索 "ain"：

```
let text = "The rain in SPAIN stays mainly in the plain";
text.match(/ain/g)    // 返回数组 [ain,ain,ain]
```

#### includes()

字串包含指定值，includes() 方法**返回 true**。

#### 改

#### replace()

**原字符串不变**

1、如果单纯是替换值，仅替换第一项，返回**新的字符串**；

2、正则表达式，可以替换多个。例子：

正则表达式包含有全局替换(g)和忽略大小写(i)的选项,这使得replace方法用'oranges'替换掉了所有出现的"apples"

```js
var re = /apples/gi;
var str = "Apples are round, and apples are juicy.";
var newstr = str.replace(re, "oranges");

// oranges are round, and oranges are juicy.
console.log(newstr);
```

#### toUpperCase()

#### toLowerCase()

#### concat()

连接两个或多个字符串，可用于代替加运算符

#### trim()

trim() 方法删除**字符串两端**的空白符:

```js
var str = "       Hello World!        ";
alert(str.trim());
```

#### 提取部分字符串的方法



#### slice()

  **返回新的字符串**，`不改变`原字符串

slice(start<0, indexEnd<0) 

#### substring()

`不改变`原字符串,  return 新的子集

substring(start, indexEnd)

`substring` 提取从 `indexStart` 到 `indexEnd`（不包括）之间的字符。特别地：

- 如果 `indexStart` 等于 `indexEnd`，`substring` 返回一个空字符串。
- 如果省略 `indexEnd`，`substring` 提取字符一直到字符串末尾。
- 如果任一参数小于 0 或为 [`NaN`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/NaN)，则被当作 0。
- 如果任一参数大于 `stringName.length`，则被当作 `stringName.length`。
- 如果 `indexStart` 大于 `indexEnd`，则 `substring` 的执行效果**就像两个参数调换了**一样。

##### 用法扩展

##### 结合str.length()提取string后几位

```js
var anyString = 'Mozilla';
var anyString4 = anyString.substring(anyString.length - 4);
console.log(anyString4);   //illa
```

##### 替换一个字符串的子字符串

仅演示功能，正常用replace();

```js
function replaceString(oldS, newS, fullS) {
// Replaces oldS with newS in the string fullS
  for (var i = 0; i < fullS.length; i++) {
    if (fullS.substring(i, i + oldS.length) == oldS) {
     fullS = fullS.substring(0, i) + newS + fullS.substring(i + oldS.length, fullS.length);
    }
  }
  return fullS;
}

replaceString("World", "Web", "Brave New World");
```

需要注意的是，如果 `oldS` 是 `newS` 的子字符串将会导致死循环。例如，尝试把 "Web" 替换成 "OtherWorld"。一个更好的方法如下：

##### 替换一个字符串的子字符串plus

```js
function replaceString(oldS, newS,fullS){
  return fullS.split(oldS).join(newS); 
    //先用oldS作为split切割的separator将fulls分为[olds左边,olds右边],再通过数组的join函数将newS作为join的separator将数组连接为新的string
}
```

#### slice() VS substring()

1. 参数为复数时：
   `slice(-1)`，相当于`slice(str.length-1)`

   而`substring(-1)`，会被视为`substring(0)`

2. 参数(start,end)  start>end时
   slice(5,3) 返回 `空字符串` --'';
   `substring(5,3)`，相当于`substring(3,5)`

3. 两者皆可省略  end  参数

4. ```js
   cpnName = cpnName.slice(29, -7);
   cpnName = cpnName.substring(29, cpnName.length - 7);
   //两者都是从【第29位到倒数第七位】截取企业名称
   cpnName  //'<span style="color:#cdddf7;">重庆欣欣向荣精细化工有限公司</span>'
   ```

   

#### substr()-废弃

substr(start, length) ， 最好不用，可能被移除

#### split()- return Array

split('separator')，**返回分割而成的Array**

```js
'syh'.split('')  //['s','y','h']
```

### 数组方法

#### fill()

fill() 方法用一个固定值填充一个数组中从起始索引到终止索引内的全部元素。不包括终止索引。

```js
var arr = Array(3).fill({}) // [{}, {}, {}];
// 需要注意如果fill的参数为引用类型，会导致都执行都一个引用类型【指针一样】
// 如 arr[0] === arr[1] 为true
arr[0].hi = "hi"; // [{ hi: "hi" }, { hi: "hi" }, { hi: "hi" }]
```

#### entries()，keys()和values()

ES6 提供三个新的方法——`entries()`，`keys()`和`values()`——用于遍历数组。可以用`for...of`循环进行遍历，区别是`keys()`是对键名的遍历、`values()`是对键值的遍历，`entries()`是对键值对的遍历。

```javascript
for (let index of ['a', 'b'].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of ['a', 'b'].values()) {
  console.log(elem);
}
// 'a'
// 'b'

for (let [index, elem] of ['a', 'b'].entries()) {
  console.log(index, elem);
}
// 0 "a"
// 1 "b"
```

#### toString()

```js
['s', 'y', 'h'].toString() //'s,y,h'

['s', 'y', 'h'].toString()  === ['s','y','h'].join(',')  //true
```

#### join()

join('separator')方法也可将所有数组元素结合为一个字符串。

它的行为类似 toString()，但是可以规定分隔符：

```js
['s','y','h'].join(',')  //'s,y,h'
['s','y','h'].join('')  //'syh'
```

返回一个所有数组元素连接的字符串。如果 `arr.length` 为0，则返回空字符串。

#### 增

#### unshift()

unshift() 方法在数组最前边添加新元素，**返回数组的新长度**

#### push()

在数据最后添加元素，**返回数组的新长度**

#### splice()

添加元素时返回`空数组`，删除元素时返回`被删除的元素组成的数组`

```js
arr.splice(startIndex , 0 , ...addItems)  
//...addItems是rest parameters写法，表示传入的项【实际传入的还是一个一个的，不是数组】
```

#### 删

#### shift() 

shift() 方法彻底删除首个数组元素，**`返回该元素的值`**

#### pop() 

pop() 方法从**数组中删除最后一个元素**，**`返回“被弹出”的值`**【即最后一个元素】

与shift()刚好相反

#### delete-废弃

使用 delete 会在数组**留下未定义的空洞**。最好用 pop() 或 shift() 取而代之。

```JavaScript
var fruits = ["Banana", "Orange", "Apple", "Mango"];
delete fruits[0];           // 把 fruits 中的首个元素改为 undefined
```

#### 查

#### includes()

返回`布尔值`

#### some()

`some()` 方法测试数组中是不是至少有1个元素通过了被提供的函数测试。它返回的是一个Boolean类型的值。

如果用一个`空数组`进行测试，在任何情况下它返回的都是`false`。

```js
const array = [1, 2, 3, 4, 5];

// checks whether an element is even
const even = (element) => element % 2 === 0;

console.log(array.some(even));
// expected output: true

```



#### every()

`every()` 方法测试一个数组内的所有元素是否都能通过某个指定函数的测试。它返回一个布尔值。

若收到一个`空数组`，此方法在一切情况下都会返回 `true`。

#### indexOf()

#### lastIndexOf()

#### `find()`

find() 返回**找到的第一个元素**，没找到返回**undefined**

```js
[1, 5, 10, 15].find(function(value, index, arr) {
  return value > 9;
}) // 10

[1, 4, -5, 10].find((n) => n < 0)
// -5
```

####  `findIndex() `

findIndex() **返回索引，找不到返回-1**，其余与find一样

此外，这两个方法(`find findIndex`)都可以发现**`NaN`，`弥补了`数组的`indexOf`方法的不足**。

```javascript
[NaN].indexOf(NaN)
// -1
[NaN].findIndex(y => Object.is(NaN, y))
// 0   findIndex方法借助Object.is实现
```

#### filter()

`filter()` 方法创建一个新数组, 其包含通过所提供函数实现的测试的所有元素。 【`返回新数组`】

```js
const words = ['spray', 'limit', 'elite', 'exuberant', 'destruction', 'present'];

const result = words.filter(word => word.length > 6);

console.log(result);
// expected output: Array ["exuberant", "destruction", "present"]
```

#### 改

#### forEach()

返回**`undefined`**

```js
arr.forEach(function(el,index,arr))
```

**应用-forEach去重并获得重复元素**

```js
let arr = [1, 3, 2, 2, 3, 4, 66, 7, 55, 66]
let chongFu = []
let newArr = arr.forEach((el, index, arr) => {
    if (arr.indexOf(el) !== index) {
        console.log(index);
        chongFu.push(...arr.splice(index, 1))
        return el
    }
})
console.log(chongFu);   //[2,66]
console.log(arr);		//[1, 3, 2, 3, 4, 66, 7, 55]
console.log(newArr);    //undefined  因为forEach返回的就是undefined
```

#### sort()

sort(compareFunction)    **返回排序后的原数组**【`原地排序`】

- 如果 `compareFunction(a, b)`结果 小于 0 ，那么 a 会被排列到 b 之前；

- 如果 `compareFunction(a, b)` 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；

- 如果 `compareFunction(a, b)` 大于 0 ， b 会被排列到 a 之前。

```js
arr.sort((a,b)=>b-a)    //arr从大到小排序
```

#### flat()

**ES6新增**

将嵌套的数组“拉平”，变成一维的数组。该方法**返回一个新数组，不改变原数组**

1、默认拉平一层，即默认flat(1)，

2、可自己设定拉平次数的参数，如flat(2)

3、若要拉平全部，使用：flat(Infinity)

4、如果原数组有空位，`flat()`方法会跳过空位。

```javascript
[1, 2, , 4, 5].flat()
// [1, 2, 4, 5]
```

#### flatMap()

`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat(1)`方法。**返回一个新数组，不改变原数组**

`flatMap()`方法对原数组的每个成员执行一个函数（相当于执行`Array.prototype.map()`），然后对返回值组成的数组执行`flat()`方法。该方法返回一个新数组，不改变原数组。

```javascript
// 相当于 [[2, 4], [3, 6], [4, 8]].flat()
[2, 3, 4].flatMap((x) => [x, x * 2])
// [2, 4, 3, 6, 4, 8]
```

`flatMap()`只能展开一层数组。

```javascript
// 相当于 [[[2]], [[4]], [[6]], [[8]]].flat()
[1, 2, 3, 4].flatMap(x => [[x * 2]])
// [[2], [4], [6], [8]]
```

#### splice()

**返回被删除的元素生成的数组，如果没删，返回空数组**

splice(start,deleteCount,item1,item2),      可加可删，而且加删的位置都可以指定！！！   实乃居家、旅行、xxxx必备良药也~

item1,item2是要加的item，deletecount为删除的个数【如果为0或者－，则必须添加item】

**注：**
deletecount大于arr.length   从start处全删除【**包括start**】

deletecount为空默认删除包括start在内的之后所有元素【同str.substring()】

#### slice()

slice(begin,end)    **返回`一个新的数组`**，这一对象是一个由 `begin` 和 `end` 决定的**原数组的浅拷贝**（包括 `begin`，不包括`end`）。原始数组不会被改变。

如果该参数为负数， 则它表示在原数组中的倒数第几个元素结束抽取。 `slice(-2,-1)` 表示抽取了原数组中的倒数第二个元素到最后一个元素（不包含最后一个元素，也就是只有倒数第二个元素）。

#### 数组方法总结

| 参数 | 返回值 | descript |
| ---- | ------ | -------- |
|      |        |          |
|      |        |          |
|      |        |          |



## D3 10.15

### try、throw、catch、finally

**try 语句使您能够测试代码块中的错误。**

**catch 语句允许您处理错误。**

**throw 语句允许您创建自定义错误。**

**finally 使您能够执行代码，在 try 和 catch 之后，无论结果如何。**

```JavaScript
function myFunction() {
    var message, x;
    message = document.getElementById("message");
    message.innerHTML = "";
    x = document.getElementById("demo").value;
    try { 
        if(x == "") throw "是空的";
        if(isNaN(x)) throw "不是数字";   //throw后不执行之后语句
         x = Number(x);
        if(x >  10) throw "太大";
        if(x <  5) throw "太小";
    }
    catch(err) {
        message.innerHTML = "错误：" + err + ".";
    }
    finally {
        document.getElementById("demo").value = "";
    }
}
```

### 属性 Getter 和 Setter

使用 getter 和 setter 时，JavaScript 可以确保更好的数据质量。

#### 写法1-不使用getter

```JavaScript
var person = {
  firstName: "Bill",
  lastName : "Gates",
  fullName : function() {
    return this.firstName + " " + this.lastName;
  }
};

// 使用方法来显示来自对象的数据：
console.log(person.fullName());
```

#### 写法2-使用getter

```JavaScript
var person = {
  firstName: "Bill",
  lastName : "Gates",
  get fullName() {
    return this.firstName + " " + this.lastName;
  }
};

// 使用 getter 来显示来自对象的数据：
console.log(person.fullName);
```

写法3-直接写函数

```js
var person = {
    firstName: "Bill",
    lastName: "Gates",
    fullName() {
        return this.firstName + " " + this.lastName;
    }
};
console.log(person.fullName());
```

写法1跟3 以**函数形式**访问 fullName：person.fullName()。

写法2 以**属性形式**访问 fullName：person.fullName。

**第二种写法提供了更简洁的语法**。（使用 getter 和 setter 时，JavaScript 可以确保更好的数据质量。）

#### 为什么使用 Getter 和 Setter？【不懂！！】

- 它提供了更简洁的语法
- 它允许属性和方法的语法相同
- 它可以确保更好的数据质量
- 有利于后台工作



|      |      |      |
| :--- | :--- | :--- |
|      |      |      |
|      |      |      |
|      |      |      |
|      |      |      |

### call() 与apply()

call()方法使用一个指定的 `this` 值和单独给出的一个或多个参数来调用一个函数。

#### 用处

`call()` 允许为不同的对象分配和调用属于一个对象的函数/方法。

`call()` 提供新的 **this** 值给当前调用的函数/方法。你可以使用 `call` 来`实现继承`：写一个方法，然后让另外一个新的对象来继承它（而不是在新对象中再写一次这个方法）。

```JavaScript
var animals = [
  {
    species: 'Lion',
    name: 'King'
  },
  {
    species: 'Whale',
    name: 'Fail'
  }
];
var ttt = [111, 222, 333]
for (var i = 0; i < animals.length; i++) {
  (function (args) { //匿名函数
    this.print = function () {
      console.log('#' + args + ' ' + this.species +
        ': ' + this.name);
    }
    // this.print();
  }).call(animals[i], ttt[i]); //通过调用该函数的 call 方法，将animals[i]作为匿名函数的this，ttt[i]作为匿名函数的参数传入，从而给animals[i]添加print方法。
}
console.log(animals)
animals[0].print()  //#111 Lion: King
animals[1].print()  //#222 Whale: Fail
```

#### 二者区别

 `call()` 方法接受的是**一个参数列表**，而 `apply()` 方法接受的是**一个包含多个参数的数组**。

```JavaScript
xxx.call(xx,arg1,arg2,arg3)

xxx.apply(xx,[arg1,arg2,arg3])
```

#### apply() 模拟数组 max 方法

由于 JavaScript 数组没有 max() 方法，因此可以应用 Math.max() 方法求最大值。

```JavaScript
Math.max.apply(null, [1,2,3]); // 返回 3,   即Math.max不需要this传入，但是需要传入【一个参数列表】，而apply()接受【数组】后将【数组】分解后传入Math.max中，就想到于 Math.max(1,2,3) 了
```

第一个参数（null）无关紧要。在本例中未使用它。

以上为ES5写法；

#### 补充-关联-ES6数组 max写法

```
Math.max(...[14, 3, 77])  //等同Math.max(14,3,77)
```

### 回调函数

函数作为参数传递时，不应该加（）

若不将函数的名称作为参数传递给另一个函数，可以传递整个函数：

```
setTimeout(function() { myFunction("I love You !!!"); }, 3000);

function myFunction(value) {
  document.getElementById("demo").innerHTML = value;
}
```

## D4 10.18

### for  ... of 与for ... in

你可能会有疑问，`for ... of`循环和`for ... in`循环有何区别？

`for ... in`循环由于历史遗留问题，它遍历的**实际上是对象的属性名称**。一个`Array`数组实际上**也是一个对象**，它的每个元素的索引被视为一个属性。

当我们手动给`Array`对象添加了额外的属性后，`for ... in`循环将带来意想不到的意外效果：

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x in a) {
    console.log(x); // '0', '1', '2', 'name'  当成对象来遍历了
}
```

`for ... in`循环将把`name`包括在内，但`Array`的`length`属性却不包括在内。

`for ... of`循环则完全修复了这些问题，它**只循环集合本身的元素**：【下例子不遍历name】

```js
var a = ['A', 'B', 'C'];
a.name = 'Hello';
for (var x of a) {
    console.log(x); // 'A', 'B', 'C'
}
```

这就是为什么要引入新的`for ... of`循环。

然而，更好的方式是**直接使用iterable内置的【forEach】方法**，它接收一个函数，每次迭代就自动回调该函数。

### array.map()

返回**`新数组，不改变数组`**

```js
array.map(function(el,index,arr), thisValue)
//	thisValue为可选。对象作为该执行回调时使用，传递给函数，用作 "this" 的值。如果省略了 thisValue，或者传入 null、undefined，那么回调函数的 this 为全局对象。
```

### reduce() 【复杂！！！】

```js
array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
//total	 		必需。初始值, 或者计算结束后的返回值。
//currentValue	必需。当前元素
//initialValue	可选。传递给函数的初始值
可简写为
arr.reduce((res=arr[0],next)=>xxxxxx)
```

**注：**

如果**没有提供initialValue**，reduce 会从索引1的地方开始执行 callback 方法，跳过第一个索引【`第一个索引作为total`】。

如果**`提供initialValue，从索引0开始`**。【即提供初始值的话，`多循环一次`】

**累加**

```js
let arr = [2, 3, 2, 2, 3, 4, 66, 7, 55, 66]
let chongFu = []
arr.reduce((total, el) => {
    console.log(total, el);
    total = total + el
    console.log(total);
    return total
}, 0)
```



## D5.10.19

### [闭包](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)

【携带状态的函数】

注意到返回的函数在其定义内部引用了局部变量`arr`，所以，当一个函数返回了一个函数后，其内部的局部变量还被新函数引用，所以，闭包用起来简单，**实现起来可不容易**。

另一个需要注意的问题是，**返回的函数并没有立刻执行，而是直到调用了f()**才执行。我们来看一个例子：

```js
function count() {
    var arr = [];
    for (var i = 1; i <= 3; i++) { //此处可以把var换成let，能用了
        arr.push(function () {
            console.log(i * i);
        });
    }
    return arr;
}
var results = count();
console.log(results[0]);
var f1 = results[0]();  //16
var f2 = results[1]();  //16
var f3 = results[2]();  //16
```

在上面的例子中，每次循环，都创建了一个新的函数，然后，把创建的3个函数都添加到一个`Array`中返回了。

你可能认为调用`f1()`，`f2()`和`f3()`结果应该是`1`，`4`，`9`，但实际结果是：

```js
f1(); // 16
f2(); // 16
f3(); // 16
//全部都是`16`！原因就在于返回的函数引用了变量`i`，但它**并非立刻执行**。等到3个函数都返回时，它们所引用的变量`i`已经变成了`4`，因此最终结果为`16`。
```

**返回闭包**时牢记的一点就是：返回函数**不要引用任何循环变量**，或者**后续会发生变化的变量**。

#### [深入理解javascript原型和闭包](https://www.cnblogs.com/wangfupeng1988/p/3977924.html)

### generator`【不会用！！！？？？】`

generator还有另一个巨大的好处，就是**把异步回调代码变成“同步”代码**。这个好处要等到后面学了AJAX以后才能体会到。

没有generator之前的黑暗时代，用AJAX时需要这么写代码：

```js
ajax('http://url-1', data1, function (err, result) {
    if (err) {
        return handle(err);
    }
    ajax('http://url-2', data2, function (err, result) {
        if (err) {
            return handle(err);
        }
        ajax('http://url-3', data3, function (err, result) {
            if (err) {
                return handle(err);
            }
            return success(result);
        });
    });
});
```

回调越多，代码越难看。

有了generator的美好时代，用AJAX时可以这么写：

```js
try {
    r1 = yield ajax('http://url-1', data1);
    r2 = yield ajax('http://url-2', data2);
    r3 = yield ajax('http://url-3', data3);
    success(r3);
}
catch (err) {
    handle(err);
}
```

### 构造函数

用`new Student()`创建的对象还从原型上获得了一个`constructor`属性，它指向函数`Student`本身：

```js
function Student(name) {
    this.name = name;
    this.hello = function () {
        alert('Hello, ' + this.name + '!');
    }
}

var xiaoming = new Student('小明');
xiaoming.name; // '小明'
xiaoming.hello(); // Hello, 小明!
```

```js
xiaoming.constructor === Student.prototype.constructor; // true
Student.prototype.constructor === Student; // true

Object.getPrototypeOf(xiaoming) === Student.prototype; // true

xiaoming instanceof Student; // true
```





## D6 10.20

### cookie【没咋看】

当一个用户成功登录后，服务器发送一个Cookie给浏览器，例如`user=ABC123XYZ(加密的字符串)...`，此后，浏览器访问该网站时，会在请求头附上这个Cookie，服务器根据Cookie即可区分出用户。

**cookie不让js读取，但是可以附在http头来供服务器读取**

JavaScript可以通过`document.cookie`读取到当前页面的Cookie

由于JavaScript能读取到页面的Cookie，而用户的登录信息通常也存在Cookie中，这就造成了巨大的安全隐患，这是因为在HTML页面中引入第三方的JavaScript代码是允许的：

JavaScript可以通过`document.cookie`读取到当前页面的Cookie

```
<!-- 当前页面在wwwexample.com -->
<html>
    <head>
        <script src="http://www.foo.com/jquery.js"></script>
    </head>
    ...
</html>
```

如果引入的第三方的JavaScript中存在恶意代码，则`www.foo.com`网站将直接获取到`www.example.com`网站的用户登录信息。

为了解决这个问题，服务器在设置Cookie时可以使用`httpOnly`，设定了`httpOnly`的Cookie将不能被JavaScript读取。这个行为由浏览器实现，主流浏览器均支持`httpOnly`选项，IE从IE6 SP1开始支持。

为了确保安全，服务器端在设置Cookie时，应该始终坚持使用`httpOnly`。

### history

`history`对象保存了浏览器的历史记录，JavaScript可以调用`history`对象的`back()`或`forward ()`，相当于用户点击了浏览器的“后退”或“前进”按钮。

这个对象属于历史遗留对象，对于现代Web页面来说，由于大量使用AJAX和页面交互，简单粗暴地调用`history.back()`可能会让用户感到非常愤怒。

新手开始设计Web页面时喜欢在登录页登录成功时调用`history.back()`，试图回到登录前的页面。这是一种错误的方法。

**任何情况，你都不应该使用`history`这个对象了**。

### querySelector

#### [CSS 选择器](https://www.runoob.com/cssref/css-selectors.html)

廖雪峰[练习题](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022310122752)

```js
// 选择<p>JavaScript</p>:
var js = document.getElementById("test-p");
// 选择<p>Python</p>,<p>Ruby</p>,<p>Swift</p>:
var arr = document.querySelectorAll(".c-red.c-green p");
// 选择<p>Haskell</p>:
var haskell = document.querySelector("#test-div div:last-child p:last-child");

// 选择<p>JavaScript</p>:
var js = document.querySelector('#test-p');
// 选择<p>Python</p>,<p>Ruby</p>,<p>Swift</p>:
var arr = document.querySelectorAll('.c-red.c-green p');
//console.log(arr)
// 选择<p>Haskell</p>:
var haskell = document.querySelectorAll(".c-green")[1].querySelector('p:last-child');
console.log(haskell)
```

### innerHTML、innerText、innerText

用`innerHTML`时要注意，是否需要写入HTML。如果写入的字符串是通过网络拿到的，要注意对字符编码来避免XSS攻击。

#### innerText、innerText

通过修改`innerText`或`innerText`属性，可以自动对字符串进行HTML编码，保证无法设置任何HTML标签

两者的区别在于读取属性时，`innerText`不返回隐藏元素的文本，而`textContent`返回所有文本

### 新建DOM

HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应。

```js
var
    list = document.getElementById('list'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.appendChild(haskell);

//动态添加style
var d = document.createElement('style');
d.setAttribute('type', 'text/css');
d.innerHTML = 'p { color: red }';
document.getElementsByTagName('head')[0].appendChild(d);
```

### 插入DOM

若插入的节点DOM树中已经存在，则**移动节点插入，而不是复制**

```js
<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
    <p id="js">JavaScript</p>
</div>

var
    js = document.getElementById('js'),
    list = document.getElementById('list');
list.appendChild(js);

<div id="list">
    <p id="java">Java</p>
    <p id="python">Python</p>
    <p id="scheme">Scheme</p>
    <p id="js">JavaScript</p>
</div>
```

#### 把子节点插入到指定的位置

```js
insertBefore(newDom, position)

var
    list = document.getElementById('list'),
    ref = document.getElementById('python'),
    haskell = document.createElement('p');
haskell.id = 'haskell';
haskell.innerText = 'Haskell';
list.insertBefore(haskell, ref);
```

#### [练习题](https://www.liaoxuefeng.com/wiki/1022910821149312/1026155949848768)

第一种直接对children排序再导入

```js
list = document.getElementById('test-list');
sort = Array.from(list.children).sort((a, b) => a.innerText > b.innerText ? 1:-1);
for (let e of sort) list.appendChild(e);
```

------

第二种先提取文本，对文本排序再逐一写入

```js
list = Array.from(document.getElementById('test-list').children);
sort = list.map(element => element.innerText).sort();
list.map((element, index) => element.innerText = sort[index])
```

### 删除DOM

要删除一个节点，首先要获得该节点本身以及它的父节点，然后，**调用父节点的`removeChild`**把自己删掉：

```
// 拿到待删除节点:
var self = document.getElementById('to-be-removed');
// 拿到父节点:
var parent = self.parentElement;
// 删除:
var removed = parent.removeChild(self);
removed === self; // true
```

注意到**删除后的节点虽然不在文档树中了，但其实它还在内存中，可以随时再次被添加到别的位置**。

#### 注意

尽量不要通过父节点找children【即parent.children[i]】删除，因为childre是动态的（除非就删除一个）

## D7 10.21

### [js调用函数时加括号与不加括号的区别](https://www.cnblogs.com/summerXll/p/6505647.html)

函数名其实就是指向函数体的指针 
不加括号， 可以认为是查看该函数的完整信息， 
不加括号传参，相当于传入函数整体 
加括号 **表示立即调用**（执行）这个函数里面的代码（花括号部分的代码）

[例子](https://www.runoob.com/try/try.php?filename=tryjs_events2)

```js
<button onclick="displayDate()">点这里</button>    //这里不加()会报错

<button id="myBtn">点这里</button>    

<script>
document.getElementById("myBtn").onclick=displayDate;  //可以正常运行
document.getElementById("myBtn").onclick=function(){displayDate()};  //正常运行
document.getElementById("myBtn").onclick=function(){displayDate};  //不能运行
document.getElementById("myBtn").onclick=displayDate();  //onclick无用，仅加载js时调用一次
function displayDate(){
	document.getElementById("demo").innerHTML=Date();
}
</script>
```



### JavaScript[单线程](https://www.liaoxuefeng.com/wiki/1022910821149312/1023022494381696)

在JavaScript中，浏览器的JavaScript执行引擎在执行JavaScript代码时，总是以单线程模式执行，也就是说，任何时候，JavaScript代码都不可能同时有多于1个线程在执行。

在JavaScript中，**执行多任务实际上都是异步调用**，比：

```js
reader.readAsDataURL(file);
```

就会**发起一个异步操作来读取文件内容**。因为是异步操作，所以我们在JavaScript代码中就不知道什么时候操作结束，因此需要先设置一个回调函数：

```js
reader.onload = function(e) {
    // 当文件读取完成后，自动调用此函数:
};
```

当文件读取完成后，JavaScript引擎将自动调用我们设置的回调函数。**执行回调函数时，文件已经读取完毕**，所以我们可以在回调函数内部安全地获得文件内容。

### [防抖与节流](https://www.bilibili.com/video/BV1SU4y1G7Hw)【多手写几遍！！】

#### [函数防抖和节流-简书](https://www.jianshu.com/p/c8b86b09daf0)

防抖和节流严格算起来应该属于性能优化的知识，但实际上遇到的频率相当高，处理不当或者放任不管就容易引起浏览器卡死。

#### 防抖(debounce)

**指触发事件后在 n 秒内函数只能执行一次，如果在 n 秒内又触发了事件，则会重新计算函数执行时间。**

防抖函数分为**非立即执行版**、**立即执行版**和**结合版**。

#### 节流(throttle)

**指连续触发事件但是在 n 秒中只执行一次函数。**节流会**稀释函数的执行频率**。

对于节流，一般有两种方式可以实现，分别是**时间戳版**、**定时器版**和**结合版**。

#### 区别

防抖是某个时间段的事件处理（如搜索框输入）；

节流是全时间轴上的事件（如窗口缩放，下滑）

防抖是控制次数，节流是控制频率

### [回调地狱与Promise对象](https://www.bilibili.com/video/BV1tB4y1T7jc/?spm_id_from=333.788.recommend_more_video.-1)

#### 同步优先,异步靠边,回调垫底



#### 获取异步数据方法



#### 1.回调函数

产生回调地狱

#### 2.new Promise

通过new Promise的resolve**得到**异步数据，调用then方法**返回**异步数据跟另一个**Promise**，然后再通过resolve**得到**另一个的异步数据，再通过then**返回**异步数据跟另一个**Promise**，然后再then。。。。。

结果就是有很多个then的**链式调用**，而且还得在**上一个函数里return下一个函数**

```js
let test = new Promise((resolve, reject) => {
    setTimeout(() => {
        let name = 's'
        resolve(name)
    }, 500);
});
let test1 = new Promise((resolve, reject) => {
    setTimeout(() => {
        let name = 'y'
        resolve(name)
    }, 500);
});
let test2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        let name = 'h'
        resolve(name)
    }, 500);
});
let test3 = new Promise((resolve, reject) => {
    setTimeout(() => {
        let name = 'ss'
        resolve(name)
    }, 500);
});

//链式调用
test.then(res => {
    console.log(res)
    return test1
}).then(res => {
    console.log(res)
    return test2
}).then(res => {
    console.log(res)
    return test3
}).then(res => console.log(res))
```

#### 3.异步同步化/ async await

像是同步运行的代码一样，**事件流等待await运行完再运行之后代码**

```js
async function syhAsync() {
    console.log(await test)
    console.log(await test1)
    console.log(await test2)
    console.log(await test3)
}
syhAsync()
```

#### promise的链式调用及简写

```html
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>

<body>
  <h1>
    Promise的返回值？？？
  </h1>
  <h2>

  </h2>
</body>

<script>
  // 网络请求: aaa -> 自己处理(10行)
  // 处理: aaa111 -> 自己处理(10行)
  // 处理: aaa111222 -> 自己处理


  // 1.返回new Promise 
  // new Promise((resolve, reject) => {
  //   setTimeout(() => {
  //     resolve('aaa')
  //   }, 1000)
  // }).then(res => {
  //   // 1.1.自己处理10行代码
  //   console.log(res, '----第一层的10行处理代码');
  //
  //   // 1.2.对结果进行第一次处理
  //   return new Promise((resolve, reject) => {
  //     // resolve(res + '111')
  //     reject('err')
  //   })
  // }).then(res => {
  //   console.log(res, '第二层的10行处理代码');
  //
  //   return new Promise(resolve => {
  //     resolve(res + '222')
  //   })
  // }).then(res => {
  //   console.log(res, '第三层的10行处理代码');
  // }).catch(err => {
  //   console.log(err);
  // })


  // // 2.返回Promise.resolve   【简写！！！】
  // // new Promise(resolve => resolve(结果))简写
  // new Promise((resolve, reject) => {
  //   setTimeout(() => {
  //     resolve('aaa')
  //   }, 1000)
  // }).then(res => {
  //   // 2.1.自己处理10行代码
  //   console.log(res, '----第一层的10行处理代码');

  //   // 2.2.对结果进行第一次处理
  //   return Promise.resolve(res + '----111----')
  // }).then(res => {
  //   console.log(res, '第二层的10行处理代码');

  //   return Promise.resolve(res + '222----')
  // }).then(res => {
  //   console.log(res, '第三层的10行处理代码');
  // })

  // // 3.Promise.resolve也省略掉，直接return【简写的最高地步！！！】，因为Promise返回的默认也是Promise？？？
  // new Promise((resolve, reject) => {
  //   setTimeout(() => {
  //     resolve('aaa')
  //   }, 1000)
  // }).then(res => {
  //   // 1.自己处理10行代码
  //   console.log(res, '----第一层的10行处理代码');

  //   // 2.对结果进行第一次处理
  //   return res + '111----'
  // }).then(res => {
  //   console.log(res, '第二层的10行处理代码');

  //   return res + '222----'
  // }).then(res => {
  //   console.log(res, '第三层的10行处理代码');
  // })


  // // 4.throw与catch的应用【遇到throw后直接执行catch函数中内容,reject是then】
  new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('aaa')
    }, 1000)
  }).then(res => {
    // 4.1.自己处理10行代码
    console.log(res, '----第一层的10行处理代码');

    // 4.2.对结果进行第一次处理
    // return Promise.reject('error message')
    throw 'error message'
  }).then(res => {
    console.log(res, '第二层的10行处理代码');

    return Promise.resolve(res + '222----')
  }).then(res => {
    console.log(res, '第三层的10行处理代码');
  }).catch(err => {
    console.log(err);
  })
</script>

</html>
```



### 定时器（timer）

#### setTimeout

```js
setTimeout(func,timer,arguements) //arguements作为参数传递给func()
```

##### setTimeout内部return问题

setTimeout、setInterval定时器的**回调函数是异步的**

程序运行遇到setTimeout的时候，会把这段代码**放到任务队列中执行**；

但是**主线程继续同步运行**，运行到最后发信息没有**return** 【因为此时setTimeout还在等待执行】 结果就是**undefined**

##### clearTimeout()

#### setInterval()

##### clearInterval()

### 同步、异步任务

在JavaScript中 所有的任务可以分为两种 一种是同步任务（synchronous）另一种是异步任务（asynchronous） 

- **JavaScript是单线程的语言**
- **Event Loop是javascript的执行机制**

#### 同步任务(主线程)

**同步任务(主线程)**指:在主线程上排队执行的任务 只有前一个任务执行完毕后 才能执行下一个任务

#### 异步任务

**异步任务**指: 不进入主线程 而进入 任务队列（task queue）的任务 等主线程的任务全部执行完成后 主线程会通过**event loop(事件循环)** 去询问任务队列中是否有可以被执行的任务了 如果有可以被执行的任务 这个时候这个任务就会被放进 主线程执行

异步的任务有：ajax的回调函数

　　　　　　　 DOM事件的回调函数

　　　　　　　 setTimeout、setInterval定时器的回调函数

### addEventListener()【没咋用过！！】

```js
target.addEventListener(type, listener, options);
target.addEventListener(type, listener, useCapture || false);

//true - 事件句柄在捕获阶段执行（即在事件捕获阶段调用处理函数）
//false- false- 默认。事件句柄在冒泡阶段执行（即表示在事件冒泡的阶段调用事件处理函数）
//当useCapture(设为true) 时，沿着DOM树向上冒泡的事件【子元素的相同type冒泡时】，不会触发listener.


//addEventListener() 方法可以更简单的控制事件（冒泡与捕获）。
//使用 addEventListener() 方法时,JavaScript 从 HTML 标记中分离开来，可读性更强;在没有控制HTML标记时也可以添加事件监听。
```



#### options 可选

- `capture`:  [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示 `listener` 会在该类型的事件捕获阶段传播到该 `EventTarget` 时触发。
- `once`:  [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示 `listener 在添加之后最多只调用一次。如果是` `true，` `listener` 会在其被调用之后自动移除。
- `passive`: [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，设置为true时，表示 `listener` 永远不会调用 `preventDefault()`。如果 listener 仍然调用了这个函数，客户端将会忽略它并抛出一个控制台警告。查看 [使用 passive 改善的滚屏性能](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/addEventListener#使用_passive_改善的滚屏性能) 了解更多.
- `signal`：[`AbortSignal`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortSignal)，该 `AbortSignal` 的 [`abort()`](https://developer.mozilla.org/zh-CN/docs/Web/API/AbortController/abort) 方法被调用时，监听器会被移除。
- ` mozSystemGroup`: 只能在 XBL 或者是 Firefox' chrome 使用，这是个 [`Boolean`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Boolean)，表示 `listener `被添加到 system group。

#### removeEventListener() 

#### *event*.preventDefault()

调用 preventDefault() 来避免浏览器对数据的默认处理

### [DOM事件流与事件委托](https://www.bilibili.com/video/BV1Xq4y1W7te)

#### 事件流

#### 事件捕获（Capture Phase）

#### 事件冒泡（Bubbling Phase）

事件是在**冒泡阶段**触发

#### 事件委托（Target）

##### 事件委托基于事件冒泡【即点击了子节点，子节点没事件，向上冒泡后父节点有事件，调用父节点事件】

通过委托元素的父级元素对父级元素下的Target进行操作

```js
leu ul = document.querySelector("#test-ul");
ul.onclick = function(e){
    console.log(e.target)  //e.target是ul里被点击的元素（比如li），即点击函数不写到li上，委托给ul来做，因为一开始ul中可能没有li，所以需要委托
}
```

### Canvas

```js
<canvas id="test-canvas" width="200" heigth="100">
    <p>你的浏览器不支持Canvas</p>
</canvas>

var canvas = document.getElementById('test-canvas');
var ctx = canvas.getContext('2d'); //2D
gl = canvas.getContext("webgl");   //3D
```

**Canvas的坐标以左上角为原点，水平向右为X轴，垂直向下为Y轴**

## D8 10.22 

### localStorage

存入的json文件需要先转化为字符串【JSON.stringify(res)】，取出时再转化为json【JSON.parse】

```js
//存储
res = res.res_syh;
res = JSON.stringify(res); //需要先转换为string
localStorage.setItem("phHistoryData", res);

//读取
let res = localStorage.getItem("phHistoryData");
res = JSON.parse(res);
console.log(res);
```

### HTML5

#### 语义元素

一个语义元素能够清楚的描述其意义给浏览器和开发者。

**无语义** 元素实例: <div> 和 <span> - 无需考虑内容.

**语义**元素实例: <form>, <table>, and <img> - 清楚的定义了它的内容.

#### 加粗、斜体、下划线

<strong><strong>加粗</strong>

<em><em>斜体</em>

<u>下划线</u>

#### 空格 大于号 小于号

空格：【&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;】

大于号：【&gt;&gt;&gt;&gt;】  greater than

小于号：【&lt;&lt;&lt;&lt;】  less than

#### table

表格最好用于展示数据，而不是布局

#### ul  无序列表

ul中只能放li

但li中能放任意元素

#### ol 有序列表

与ul差不多，只不过在li前边有序号

#### 自定义列表 

dl dt dd

```html
    <dl>
        <dt>联系我</dt>
        <dd>微信</dd>
        <dd>QQ</dd>
        <dd>微博</dd>
        <dd>github</dd>
    </dl>
```

#### emmet语法

![emmet语法](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022110824777.png)

```html
ul>li.id$*5>a
<ul>
	<li class="id1"><a href="|">|</a></li>
	<li class="id2"><a href="|">|</a></li>
	<li class="id3"><a href="|">|</a></li>
	<li class="id4"><a href="|">|</a></li>
	<li class="id5"><a href="|">|</a></li>
</ul>
```

#### data-set dataset

```html
<div id="user" data-id="1234567890" data-user="johndoe" data-date-of-birth>John Doe</div>
```

```js
const el = document.querySelector('#user');

// el.id === 'user'
// el.dataset.id === '1234567890'
// el.dataset.user === 'johndoe'
// el.dataset.dateOfBirth === ''

// set a data attribute
el.dataset.dateOfBirth = '1960-10-03';
// Result: el.dataset.dateOfBirth === '1960-10-03'

delete el.dataset.dateOfBirth;
// Result: el.dataset.dateOfBirth === undefined

if ('someDataAttr' in el.dataset === false) {
  el.dataset.someDataAttr = 'mydata';
  // Result: 'someDataAttr' in el.dataset === true
}

```



### CSS

#### CSS引用方式

##### 行内样式

##### 内部样式表

```css
      p {
          font-style: italic;  //切斜
      }
      em {
            /* 让倾斜的字体不倾斜 */
            font-style: normal;
      }
        p {
            font-size: 24px;
            /* 文本的第一行首行缩进 多少距离  */
            /* text-indent: 20px; */
            /* 如果此时写了2em 则是缩进当前元素 2个文字大小的距离  */
            text-indent: 2em;
            line-height: 25px;    /* 行间距 */
        }
```

##### 外部样式表

```html
<head>
	<link ref="stylesheet" href="地址"></link>
</head>
```

#### CSS的元素显示模式

HTML中将元素分为**块元素**与**行内元素（内联元素）**

##### 块元素

![image-20211022112744254](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022112744254.png)

![image-20211022112921268](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022112921268.png)

##### 行内元素

![image-20211022113352078](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022113352078.png)

##### 行内块元素（民科，没有官方说法）

![image-20211022113718654](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022113718654.png)

##### 总结

![image-20211022113808313](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211022113808313.png)

##### 元素模式转换

前两个常用

```css
display:block;
display:inline;
display:inline-block;
```

### CSS-backkground

background-position:x y;

如果要写position，**x跟y都得写上，中间空格**

```css
background-image: url(images/logo.png)

/* 1.背景图片不平铺 */
/* background-repeat: no-repeat; */
/* 2.默认的情况下,背景图片是平铺的 */
/* background-repeat: repeat; */
/* 3. 沿着x轴平铺 */
/* background-repeat: repeat-x; */
/* 4. 沿着Y轴平铺 */
background-repeat: repeat-y;

方位（left right center top）
background-position: left center;

精度定位
/* background-position: 50px 20px; */

/* 把背景图片固定住，不会随着屏幕滚动而滚动 */
 background-attachment: fixed;
```

#### backkground复合写法

```css
background: black url(images/bg.jpg) no-repeat fixed center top;
```

### CSS三大特性

#### 层叠性

也就是重复的覆盖，只有一个

#### 继承性

子元素继承父元素的样式

#### 优先性

继承<元素选择器<类/伪类选择器<id选择器<行内样式<!import

### 盒子模型

#### border

```css
table,
td, th {
    border: 1px solid pink;
    /* 合并相邻的边框 */
    border-collapse: collapse;
    font-size: 14px;
    text-align: center;
}
```

边框(border)**会影响盒子的实际大小**

#### padding【是否撑大盒子？】

```
padding:上 右 下 左   （顺时针）
padding: 上下 左右
```

padding会影响盒子的大小，也就是说，指定了盒子的宽度、长度，再设置内边距，会撑大盒子，

**但是！！**  如果**不指定width、height  则不会撑大盒子**

`解决方案`

```
box-sizing:content-box;   //默认值，即padding和margin会撑大盒子
box-sizing:border-box;    //CSS3新特性，此时盒子的实际宽度就是给定宽度，不会撑大盒子
```

#### margin

写法规则同padding

### 行内(块)元素居中

#### 水平居中

 行内元素或者行内块元素水平居中**给其父元素添加** text-align:center 即可 

#### 垂直居中

让内部文字的行高度等于**外部块元素**高度（line-height = height   数值相等）

### 块级元素居中

**注：对行内块元素无效**

#### 水平居中

```css
margin：0,auto
```

#### 垂直居中

```css
.son {
    position: absolute;
    width: 30px;
    height: 40px;
    bottom: 50%;	
    left: 50%;
    margin-left: -15px;
    margin-top: 20px;
    background-color: rgb(241, 59, 59);
    color: royalblue;
}
```



## 斐波那契

0 = 1

1 =1

2 = 0+1

3=2+1 = 0 + 1x2

4 = 3+2 = 0x2 +1x3

5 = 4+3 = 0x3 + 1x5

6 = 5+4 = 0x5 +1x8

## D9 10.23

### 嵌套块元素塌陷【易错！】

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>外边距合并-嵌套块级元素垂直外边距塌陷</title>
    <style>
        .father {
            width: 400px;
            height: 400px;
            background-color: purple;
            margin-top: 50px;
            /* 垂直外边距塌陷：设置子元素margin时，margin延申到父元素上，不是相对于父元素设置外边距
            在以下三种方法，常用为overflow */
            /* border: 1px solid red; */
            /* border: 1px solid transparent; */
            /* padding: 1px; */
            overflow: hidden;   //为啥可以？？？？
        }
        
        .son {
            width: 200px;
            height: 200px;
            background-color: pink;
            margin-top: 100px;
            /* margin: 100px auto; */
            /* 设置块级元素水平居中 */
        }
    </style>
</head>

<body>
    <div class="father">
        <div class="son"></div>
    </div>
</body>

</html>
```

#### 清除默认内外边距

```css
/* 这句话也是我们css 的第一行代码 */
* {
	margin: 0;
	padding: 0;
}
```

### box-shadow与text-shadow

#### box-shadow

```
box-shadow: *h-shadow v-shadow blur spread color* inset;
```

**注意：**boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。

| 值         | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| *h-shadow* | 必需的。水平阴影的位置。允许负值                             |
| *v-shadow* | 必需的。垂直阴影的位置。允许负值                             |
| *blur*     | 可选。模糊距离                                               |
| *spread*   | 可选。阴影的大小                                             |
| *color*    | 可选。阴影的颜色。在[CSS颜色值](https://www.runoob.com/cssref/css_colors_legal.aspx)寻找颜色值的完整列表 |
| inset      | 可选。从外层的阴影（开始时）改变阴影内侧阴影                 |

#### text-shadow

```
text-shadow: 5px 5px 6px rgba(0, 0, 0, .3);
```

### CSS浮动

#### 传统PC网页的三种布局方式

标准流、浮动、定位

### float【清除浮动？！！】

**float可以让多个块级元素一行显示在父块级元素内**

#### 特点

1.浮动的元素**脱离了标准流（脱标）**,不占据原来位置

2.**多个盒子设置浮动**，这些盒子在**一行显示**且顶端对齐

3.盒子具有行内块元素（即给块级元素或者行内元素设置浮动，等于让他们变成了行内块元素）

​		块内元素添加浮动后宽度由其中内容决定

#### 清除浮动

```css
clear:both;
```

##### 为什么清楚浮动

##### 清除浮动的本质

清除浮动元素脱离标准流造成的影响

##### 闭合浮动（三类方法）

清除浮动\闭合浮动【插入的元素必须为**块元素**】

- 额外标签法；
- 父级添加【overflow:hidden | auto | scroll 】;    缺点：无法显示溢出的部分
- 伪元素法【1.只after（只加后边）；2.前后都加伪元素】

##### 清除浮动的方法

### ul>li>a

实际开发中，使用li包含链接，因为直接使用多个a标签，搜索引擎容易辨别会堆叠关键字嫌疑（从而被搜索引擎降权、影响网站排名）

### position

五种（4+1）

#### sticky

具有相对跟绝对的特点，但是兼容性很差，ie不支持

#### 定位总结

![image-20211023223906922](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211023223906922.png)

### 绝对-相对定位

#### relative

##### relative**不脱离文档流**

position:relative时，top,left,right,bottom是**相对于自身的位置变化**。

##### 注意

body默认**宽度为浏览器100%的值，高度为0**

所以body下第一个div设置为relative时，宽度可以百分比，但是高度不行【**只能写数值**】；

**同理**,left跟right能写百分比，但是top跟bottom只能写数值

#### absolute

绝对定位的元素的位置相对于**最近的已定位祖先元素**，如果元素没有已定位的祖先元素，那么它的位置**相对于最初的包含块**【body】

#### 父父子子

**父为绝时候**，子相可以设置百分比；

子相的父元素**只要有高度**【1.父为绝，父的高度可设置百分比；2.父为相，父设置的高度为数值。】

**就可以**为子相设置百分比，否则百分比无效。

**若**子相没有父元素或者父元素没有高度【body下第一个div】，设置高度百分比无效【只能设置为数值】，相对定位元素按照内部内容高度为准

##### 父-子

##### 绝-相

##### 绝-绝

##### 相-绝【常用】

子使用绝对定位，则父需要使用相对定位

##### 相-相

#### 生而为爹，我很抱歉！

相对定位生来就是当爹的

### float与absolute

#### 相同点

都脱离了文档流

#### 不同点

absolute**压住文档标准流**文字；

float**不压文档标准流**文字【float本来就是为了**文字环绕**设计出的】

## D10 10.25 -复习



## D11 10.26 -复习



## D12 10.27

### 元素的显示与隐藏

#### diaplay【常用】

```
display: none;
/* display: block; */   除了是块级元素外，还有显示元素的意思
```

display: none;只是隐藏元素【隐藏后不占据原来位置】，并不删除

#### visibility

```css
visibility:hidden;
visibility:visible;
```

**保留位置**

#### overflow

overflow:visible|auto|hidden|scroll

**scroll**时不溢出也显示滚动条

**auto**根据内容与div高度自动选择

### sprites-精灵图

为了减轻服务器压力，减少请求次数

background-position

坐标系与canvas一致，x轴、y轴移动是图片移动，即图片向左移，向上移【因为图片默认是**左上角为原点**】

#### 缺点

1.图片很大，浪费带宽与内存

2.放大失真

3.二次编辑困难

#### 优点

1.比较大、不常变化的背景图可以使用sprites

2.减小请求次数

3.即简单的用iconfont、复杂的用sprites

### iconfont

针对sprites的缺点，诞生了iconfont【即像是文本一样的图标】

阿里图标矢量库

### CSS三角



```html
    <div class="jd">
        <span></span>
    </div>
        .jd span {
        position: absolute;
        right: 15px;
        top: -10px;
        width: 0;
        height: 0;
        /* 为了照顾兼容性 */
        line-height: 0;  
        font-size: 0;
        border: 5px solid transparent;
        border-bottom-color: pink;   //生成一个向上的箭头
    }
```

### cursor

```js
<ul>
    <li style="cursor: default;">我是默认的小白鼠标样式</li>
    <li style="cursor: pointer;">我是鼠标小手样式</li>
    <li style="cursor: move;">我是鼠标移动样式</li>
    <li style="cursor: text;">我是鼠标文本样式</li>
    <li style="cursor: not-allowed;">我是鼠标禁止样式</li>
</ul>
```

### input textarea

```css
<style>
    input,
    textarea {
        /* 取消表单轮廓，focus时候边框颜色变深*/
        outline: none;
    }

    textarea {
        /* 防止拖拽文本域 */
        resize: none;
    }
</style>
```

### vertical-align

**vertical-align : top | middle| bottom**

实现文字与表单【图片】等**行内【块】**元素对齐;

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>利用vertical-align实现图片文字垂直居中对齐</title>
    <style>
        img {
            /* vertical-align: bottom; */
            /* 让图片和文字垂直居中 */
            vertical-align: middle;
            /* vertical-align: top; */
        }
        textarea {
            vertical-align: middle;
        }
    </style>
</head>
<body>
    <img src="images/ldh.jpg" alt="">  pink老师是刘德华

    <br>
    <textarea name="" id="" cols="30" rows="10"></textarea> 请您留言
</body>
</html>
```

#### 解决图片底部有默认空白缝隙问题

bug :图片底侧会有一个空白缝隙,原因是**行内块元素会和文字的基线对齐**。

**解决方法：**

1,给图片添加vertical-align:middle l topl bottom等。(提倡使用的)
2·把图片转换为块级元素display: block;

### 溢出文字隐藏

#### 一行

```css
.syh_hide{
    /* 这个单词的意思是如果文字显示不开自动换行 */
    /* white-space: normal; */
    /* 1.这个单词的意思是如果文字显示不开也必须强制一行内显示 */
    white-space: nowrap;
    /* 2.溢出的部分隐藏起来 */
    overflow: hidden;
    /* 3. 文字溢出的时候用省略号来显示 */
    text-overflow: ellipsis;
}
```



#### 多行

兼容性不行，而且设置长度困难

```css
div {
    width: 150px;
    height: 65px;
    background-color: pink;
    margin: 100px auto;
    overflow: hidden;
    text-overflow: ellipsis;
    /* 弹性伸缩盒子模型显示 */
    display: -webkit-box;
    /* 限制在一个块元素显示的文本的行数 */
    -webkit-line-clamp: 3;
    /* 设置或检索伸缩盒对象的子元素的排列方式 */
    -webkit-box-orient: vertical;
}
```

### 布局技巧

#### margin负值的应用

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>margin负值的巧妙运用</title>
    <style>
        ul li {
            position: relative;
            float: left;
            list-style: none;
            width: 150px;
            height: 200px;
            border: 1px solid red;
            margin-left: -1px;
        }

        /* ul li:hover {
           1. 如果盒子没有定位，则鼠标经过添加相对定位即可
        position: relative;
        border: 1px solid blue;

       } */
        ul li:hover {
            /* 2.如果li都有定位，则利用 z-index提高层级 */  更高的方法
            z-index: 1;
            border: 1px solid blue;
        }
    </style>
</head>

<body>
    <ul>
        <li>1</li>
        <li>2</li>
        <li>3</li>
        <li>4</li>
        <li>5</li>
    </ul>
</body>

</html>
```

#### alt+shift  多行操作【vscode】

#### 文字围绕浮动元素

#### 行内块的运用

翻页例子

#### CSS三角强化

京东价格--纯CSS写

### HTML5新特性

#### input的type

tel、number、email、search

要在**表单域**内验证才有效

#### 新增语义元素

```html
<body>
    <header>头部标签</header>
    <nav>导航栏标签</nav>
    <section>某个区域</section>
</body>
```

#### video

| [autoplay](https://www.w3school.com.cn/tags/att_video_autoplay.asp) | autoplay | 如果出现该属性，则视频在就绪后马上播放。【chrome中需要muted】 |
| ------------------------------------------------------------ | -------- | ------------------------------------------------------------ |
| [controls](https://www.w3school.com.cn/tags/att_video_controls.asp) | controls | 如果出现该属性，则向用户显示控件，比如播放按钮。             |
| [height](https://www.w3school.com.cn/tags/att_video_height.asp) | *pixels* | 设置视频播放器的高度。                                       |
| [loop](https://www.w3school.com.cn/tags/att_video_loop.asp)  | loop     | 如果出现该属性，则当媒介文件完成播放后再次开始播放。         |
| [muted](https://www.w3school.com.cn/tags/att_video_muted.asp) | muted    | 规定视频的音频输出应该被静音。                               |
| [poster](https://www.w3school.com.cn/tags/att_video_poster.asp) | *URL*    | 规定视频下载时显示的图像，或者在用户点击播放按钮前显示的图像。 |
| [preload](https://www.w3school.com.cn/tags/att_video_preload.asp) | preload  | 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 "autoplay"，则忽略该属性。 |
| [src](https://www.w3school.com.cn/tags/att_video_src.asp)    | *url*    | 要播放的视频的 URL。                                         |
| [width](https://www.w3school.com.cn/tags/att_video_width.asp) | *pixels* | 设置视频播放器的宽度。                                       |

#### audio

类似video

### CSS3新特性

### CSS3选择器

#### 属性选择器

通过选择元素中属性定义样式【三种方式】

1. 包含某个属性；
2. 包含的属性 的属性内容；
3. 正则查找【1.属性内容以xx开始；2.以xx结束；3.包含xx】

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CSS3新增属性选择器</title>
    <style>
        /* 必须是input 但是同时具有 value这个属性 选择这个元素  [] */
        /* input[value] {
            color:pink;
        } */
        /* 只选择 type =text 文本框的input 选取出来 */
        input[type=text] {
            color: pink;
        }
        /* 选择首先是div 然后 具有class属性 并且属性值 必须是 icon开头的这些元素 */
        div[class^=icon] {
            color: red;
        }
        section[class$=data] {
            color: blue;
        }
        div.icon1 {
            color: skyblue;
        }
        /* 类选择器和属性选择器 伪类选择器 权重都是 10 */
    </style>
</head>
<body>
    <!-- 1. 利用属性选择器就可以不用借助于类或者id选择器 -->
    <!-- <input type="text" value="请输入用户名">
    <input type="text"> -->
    <!-- 2. 属性选择器还可以选择属性=值的某些元素 重点务必掌握的 -->
    <input type="text" name="" id="">
    <input type="password" name="" id="">
    <!-- 3. 属性选择器可以选择属性值开头的某些元素 -->
    <div class="icon1">小图标1</div>
    <div class="icon2">小图标2</div>
    <div class="icon3">小图标3</div>
    <div class="icon4">小图标4</div>
    <div>我是打酱油的</div>
    <!-- 4. 属性选择器可以选择属性值结尾的某些元素 -->
    <section class="icon1-data">我是安其拉</section>
    <section class="icon2-data">我是哥斯拉</section>
    <section class="icon3-ico">哪我是谁</section>

</body>
</html>
```

#### 结构伪类选择器

三种

1. ul li:first-child
2. ul li:last-child
3. ul li:nth-child(n)

##### nth-child(n)

##### 选出所有奇数（偶数）

```css
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CSS3新增结构伪类选择器-nth-child</title>
    <style>
        /* 1.把所有的偶数 even的孩子选出来 */
        ul li:nth-child(even) {
            background-color: #ccc;
        }

        /* 2.把所有的奇数 odd的孩子选出来 */
        ul li:nth-child(odd) {
            background-color: gray;
        }

        /* ！！！！！！！！！！！！！！！！！！！！！！！ */
        /* 3.nth-child(n) 从0开始 每次加1 往后面计算  这里面必须是n 不能是其他的字母 选择了所有的孩子*/
        /* ol li:nth-child(n) {
            background-color: pink;
        } */
        /* 4.nth-child(2n)母选择了所有的偶数孩子 等价于 even*/
        /* ol li:nth-child(2n) {
            background-color: pink;
        }
        选择1，3，5，7
        ol li:nth-child(2n+1) {     
            background-color: skyblue;
        } */
        /* ol li:nth-child(n+3) {
            background-color: pink;
        } */
        /* 倒着来 */
        ol li:nth-child(-n+3) {
            background-color: pink;
        }
    </style>
</head>

<body>
    <ul>
        <li>我是第1个孩子</li>
        <li>我是第2个孩子</li>
        <li>我是第3个孩子</li>
        <li>我是第4个孩子</li>
        <li>我是第5个孩子</li>
        <li>我是第6个孩子</li>
        <li>我是第7个孩子</li>
        <li>我是第8个孩子</li>
    </ul>
    <ol>
        <li>我是第1个孩子</li>
        <li>我是第2个孩子</li>
        <li>我是第3个孩子</li>
        <li>我是第4个孩子</li>
        <li>我是第5个孩子</li>
        <li>我是第6个孩子</li>
        <li>我是第7个孩子</li>
        <li>我是第8个孩子</li>
    </ol>
</body>

</html>
```

##### nth-of-type(n)与nth-child

```css
/* nth-child 会把所有的盒子都排列序号 */
/* 执行的时候首先看  :nth-child(1) 之后回去看 前面 div */
section div:nth-child(1) {
    background-color: red;
}


/* nth-of-type 会把指定元素的盒子排列序号 */
/* 执行的时候首先看  div指定的元素  之后回去看 :nth-of-type(1) 第几个孩子 */
section div:nth-of-type(1) {
    background-color: blue;
}
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>CSS3新增选择器nth-type-of</title>
    <style>
        ul li:first-of-type {
            background-color: pink;
        }

        ul li:last-of-type {
            background-color: pink;
        }

        ul li:nth-of-type(even) {
            background-color: skyblue;
        }

        /* nth-child 会把所有的盒子都排列序号 */
        /* 执行的时候首先看  :nth-child(1) 之后回去看 前面 div */
        section div:nth-child(1) {
            background-color: red;
        }


        /* nth-of-type 会把指定元素的盒子排列序号 */
        /* 执行的时候首先看  div指定的元素  之后回去看 :nth-of-type(1) 第几个孩子 */
        section div:nth-of-type(1) {
            background-color: blue;
        }
    </style>
</head>

<body>
    <ul>
        <li>我是第1个孩子</li>
        <li>我是第2个孩子</li>
        <li>我是第3个孩子</li>
        <li>我是第4个孩子</li>
        <li>我是第5个孩子</li>
        <li>我是第6个孩子</li>
        <li>我是第7个孩子</li>
        <li>我是第8个孩子</li>
    </ul>
    <!-- 区别 -->
    <section>
        <p>光头强</p>
        <div>熊大</div>
        <div>熊二</div>
    </section>
</body>

</html>
```

### 未完待续

## D13 10.28

### 续-CSS3选择器

#### 伪元素选择器

```css
/* div::before 权重是2 */
div::before {
    /* 这个content是必须要写的 */
    /* display: inline-block; */
    content: '我';
    /* width: 30px;
    height: 40px;
    background-color: purple; */
}

div::after {
    content: '小猪佩奇';
}
```



- 伪元素选择器可以**利用CSS创建新标签元素**,而需HTML,从而**简化HTM结构**。
- before和after创建的元素属于**行内元素**【即无法设置宽度、高度；但是可更改为行内块元素】
- 伪元素在文档树中**找不到**
- before和after必须有**content**属性
- 伪元素权重为1

#### 伪元素清除浮动【两种方式】

**额外标签法**的升级和优化

- 只在后边加

![image-20211028093226067](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211028093226067.png)

- 前后都加

![image-20211028093226067](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211028093226067.png)

### CSS3盒子模型

```css
box-sizing:content-box;   //默认值，即padding和margin会撑大盒子
box-sizing:border-box;    //CSS3新特性，此时盒子的实际宽度就是给定宽度，不会撑大盒子
```

注意：border-box时，如果要设置文字垂直居中对齐，本来是直接【line-height = height 】就行，现在得【line-height = height - padding】【只 - padding就行，因为margin是在box外部的】

### CSS3-transition[4个]

transition: 变化的属性 花费时间 运动曲线 何时开始

```css
<style>
    div {
        width: 200px;
        height: 100px;
        background-color: pink;
        /* transition: 变化的属性 花费时间 运动曲线 何时开始; */
        /* transition: width .5s ease 0s, height .5s ease 1s; */
        /* 如果想要写多个属性，利用逗号进行分割 */
        /* transition: width .5s, height .5s; */
        /* 如果想要多个属性都变化，属性写all就可以了 */
        /* transition: height .5s ease 1s; */
        /* 谁做过渡，给谁加 */
        transition: all 0.5s;
    }
    div:hover {
        width: 400px;
        height: 200px;
        background-color: skyblue;
    }
</style>
```



### 其他新特性

#### 图片模糊处理filter

```css
img {
    /* blur是一个函数 小括号里面数值越大，图片越模糊 注意数值要加px单位 */
    filter: blur(15px);
}
img:hover {
    filter: blur(0);
}
```

#### calc

```css
width: calc(100% - 30px);
```

### TDK SEO优化

### 2D-transform

#### 注意！！

当有translate和其他变化时，把translate放在最前边，要不然translate会以rotate【等】之后的位置开始移动！

#### translate

```css
transform:translate(X,Y);   //单位px
transform:translateX();
transform:translateY();
```

##### 特性

1. translate**不影响**其他元素位置【类似于相对定位】；
2. 对**行内标签没有效果**；
3. 移动的百分比以自身为参照

##### 利用translate居中绝对定位元素

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }

        div {
            position: relative;
            width: 500px;
            height: 500px;
            background-color: pink;
            /* 1. 我们tranlate里面的参数是可以用 % */
            /* 2. 如果里面的参数是 % 移动的距离是 盒子自身的宽度或者高度来对比的 */
            /* 这里的 50% 就是 50px 因为盒子的宽度是 100px */
            /* transform: translateX(50%); */
        }

        p {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 200px;
            height: 200px;
            background-color: purple;
            /* margin-top: -100px;
            margin-left: -100px; */
            /* translate(-50%, -50%)  盒子往上走自己高度的一半   */
            transform: translate(-50%, -50%);
        }

        span {
            /* translate 对于行内元素是无效的 */
            transform: translate(300px, 300px);
        }
    </style>
</head>

<body>
    <div>
        <p></p>
    </div>
    <span>123</span>
</body>

</html>
```

#### rotate

```css
transform:rorate(360deg)   //单位deg
```

##### CSS3使用rotate写三角

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        div {
            position: relative;
            width: 249px;
            height: 35px;
            border: 1px solid #000;
        }

        div::after {
            content: "";
            position: absolute;
            top: 8px;
            right: 15px;
            width: 10px;
            height: 10px;
            /* 只要两个等长边框，再旋转45度 */
            border-right: 1px solid #000;
            border-bottom: 1px solid #000;
            transform: rotate(45deg);
            transition: all 0.2s;
        }

        /* 鼠标经过div  里面的三角旋转 */
        div:hover::after {
            transform: rotate(225deg);
        }
    </style>
</head>

<body>
    <div></div>
</body>

</html>
```

##### 设置旋转原点

```css
<style>
    div {
        width: 200px;
        height: 200px;
        background-color: pink;
        margin: 100px auto;
        transition: all 1s;
        /* 1.可以跟方位名词 */
        /* transform-origin: left bottom; */
        /* 2. 默认的是 50%  50%  等价于 center  center */
        /* 3. 可以是px 像素 */
        transform-origin: 50px 50px;
    }
    
    div:hover {
        transform: rotate(360deg);
    }
</style>
```

**实例**

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        div {
            overflow: hidden;
            width: 200px;
            height: 200px;
            border: 1px solid pink;
            margin: 10px;
            float: left;
        }
        
        div::before {
            content: "黑马";
            display: block;
            width: 100%;
            height: 100%;
            background-color: hotpink;
            transform: rotate(180deg);
            transform-origin: left bottom;
            transition: all 0.4s;
        }
        /* 鼠标经过div 里面的before 复原 */
        
        div:hover::before {
            transform: rotate(0deg);
        }
    </style>
</head>

<body>
    <div></div>
    <div></div>
    <div></div>
</body>

</html>
```

#### scale

scale不会影响其他的盒子 而且可以设置缩放的中心点

```css
transform:scale(x,y);  缩放倍数
transform:scale(xy);   只写一个是x、y都缩放
```

#### transform总结

### CSS3-animation

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
    <style>
        @keyframes move {
            0% {
                transform: translate(0, 0);
            }
            100% {
                transform: translate(1000px, 0);
            }
        }
        
        div {
            width: 100px;
            height: 100px;
            background-color: pink;
            /* 动画名称 */
            animation-name: move;
            /* 持续时间 */
            /* animation-duration: 2s; */
            /* 运动曲线 */
            /* animation-timing-function: ease; */
            /* 何时开始 */
            animation-delay: 1s;
            /* 重复次数  iteration 重复的 conut 次数  infinite  无限 */
            /* animation-iteration-count: infinite; */
            /* 是否反方向播放 默认的是 normal  如果想要反方向 就写 alternate */
            /* animation-direction: alternate; */
            /* 动画结束后的状态 默认的是 backwards  回到起始状态 我们可以让他停留在结束状态 forwards */
            /* animation-fill-mode: forwards; */
            /* animation: name duration timing-function delay iteration-count direction fill-mode; */
            /* animation: move 2s linear 0s 1 alternate forwards; */
            /* 前面2个属性 name  duration 一定要写 */
            /* animation: move 2s linear  alternate forwards; */
        }
        
        div:hover {
            /* 鼠标经过div 让这个div 停止动画，鼠标离开就继续动画 */
            animation-play-state: paused;
        }
    </style>
</head>

<body>
    <div>

    </div>
</body>

</html>
```

### transform:translate3d

- translate3d(x,y,z);  **单位都是px**
- ratate3d(x,y.z,deg);  
- perspective;   近大远小
- transform-style;

#### translate3d(x,y,z)

  **单位都是px**

```CSS
transform:translateX;
transform:translateY;
transform:translateZ;
```

#### perspective

#### ratate3d

需要**先定下perspective**【父元素内】

左手准则：大拇指 指向正轴，四指方向为正角度！！

ratate3d(x,y.z,deg);   **x,y,z是向量**

**rotate算是rotateZ**

#### transform-style

是否开启3d空间，**写到父元素内**

```css
/* 让子元素保持3d立体空间环境 */
transform-style: preserve-3d;   //默认flat，不开启3d空间
```

## D14 10.29

### 完结撒花

CSS3-HTML5-pink老师—**完结撒花**

### 浏览器私有前缀

![image-20211029092042615](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211029092042615.png)

### 移动端

### 流动式布局

### flex布局

#### [最全的](https://blog.csdn.net/qq_44537625/article/details/100040169)

#### 对比传统布局

**传统布局**

1. 兼容性好；
2. 布局繁琐；
3. 局限性,不能再移动端很好的布局

**flex弹性布局**

1. 操作方便,布局极为简单,移动端应用很广泛；
2. PC端浏览器支持情况较差；
3. IE 11或更低版本,不支持或仅部分支持

**建议：**

- 如果是PC端页面布局,我们还是传统布局。
- 如果是移动端或者不考虑兼容性问题的PC端页面布局,我们还是使用flex弹性布局

#### flex原理

总结flex布局原理:就是通过**给父盒子添加flex属性**,来控制子盒子的**位置和排列方式**

flex是flexible Box的缩写,意为"弹性布局",用来为盒状模型提供最大的灵活性,任何一个容器都可以
指定为flex布局。

- 当我们为父盒子设为flex布局以后,子元素的float, clear和vertical-align属性将失效。
- 伸缩布局=弹性布局=伸缩盒布局=弹性盒布局=flex布局

采用Flex布局的元素,称为Flex容器( **flex container** ) ,简称"容器"。它的所有子元素自动成为容
器成员,称为Flex项目**(flex item )** ,简称"项目"

#### [flex容器]常见属性

![image-20211029103515620](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211029103515620.png)

#### [flex项目]常见属性

![image-20211029104818697](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211029104818697.png)

### Vue

#### 渐进式

#### 响应式

#### vue的mvvm

#### vue的生命周期

### 基础指令

#### mustache

```
{{ number + 1 }}
{{ ok ? 'YES' : 'NO' }}
{{ message.split('').reverse().join('') }}

<!-- 这是语句，不是表达式 -->
{{ var a = 1 }}
<!-- 流控制也不会生效，请使用三元表达式 -->
{{ if (ok) { return message } }}
```

#### v-once

定义它的元素或组件只会渲染一次，包括元素或者组件的所有字节点。首次渲染后，**不再随着数据的改变而重新渲染**。也就是说使用v-once，那么该块都将被视为静态内容。可以用于**优化更新性能。**

#### v-html

vue默认以**纯字符串**解析数据，如果内容是dom元素，要写v-html

#### v-text

```html
<h2 v-text='message'>'这里数据将被message覆盖'</h2>
```

#### v-pre

v-pre用于**跳过**这个元素和它子元素的编译过程,用于显示原本的Mustache语法。

#### v-cloak【了解】

在vue解析之前有一个属性v-cloak，可以设置其显示与否，解析之后这个属性自动消失

## D15 10.30

### v-bind及其语法糖

#### v-bind动态绑定class！！【高级！！】

**首先！：绑定class有两种方式**：

1. 对象语法
2. 数组语法【使用较少】

#### 对象方法

```
用法一：直接通过{}绑定一个类
<h2 :class="{'active': isActive}">Hello World</h2>

用法二：也可以通过判断，传入多个值
<h2 :class="{'active': isActive, 'line': isLine}">Hello World</h2>

用法三：和普通的类同时存在，并不冲突
注：如果isActive和isLine都为true，那么会有title/active/line三个类
<h2 class="title" :class="{'active': isActive, 'line': isLine}">Hello World</h2>

用法四：如果过于复杂，可以放在一个methods或者computed中
注：classes是一个计算属性
<h2 class="title" :class="classes">Hello World</h2>

```

#### 数组方法

```
用法一：直接通过{}绑定一个类
<h2 :class="['active']">Hello World</h2>

用法二：也可以传入多个值
<h2 :class=“[‘active’, 'line']">Hello World</h2>

用法三：和普通的类同时存在，并不冲突
注：会有title/active/line三个类
<h2 class="title" :class=“[‘active’, 'line']">Hello World</h2>

用法四：如果过于复杂，可以放在一个methods或者computed中
注：classes是一个计算属性
<h2 class="title" :class="classes">Hello World</h2>
```

#### 数组绑定attribute

```
<a v-bind:[attributeName]="url"> ... </a>
```

### v-on及其语法糖

v-on用于**绑定事件监听器**

v-on不仅仅可以用于**监听DOM事件**，也可以用于组件间的**自定义事件**

```js
v-on:click="counter++”
@click="counter++”
```

#### v-on参数

情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。

但是注意：如果方法本身中有一个参数，那么会默认**将原生事件event参数**传递进去

情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。

#### v-on修饰符

修饰符 (modifier) 是以半角句号 `.` 指明的特殊后缀，用于指出一个指令应该以特殊方式绑定。例如，`.prevent` 修饰符告诉 `v-on` 指令对于触发的事件调用 `event.preventDefault()`：

```js
<form v-on:submit.prevent="onSubmit">...</form>
```

在接下来对 [`v-on`](https://cn.vuejs.org/v2/guide/events.html#事件修饰符) 和 [`v-for`](https://cn.vuejs.org/v2/guide/forms.html#修饰符) 等功能的探索中，你会看到修饰符的其它例子。

#### 自定义事件的流：

在子组件中，通过**$emit()**来触发事件。

在父组件中，通过**v-on来监听子组件事件**。

### computed

模板内的表达式非常便利，但是设计它们的初衷是用于简单运算的。在模板中放入太多的逻辑会让模板过重且难以维护。所以，对于任何复杂逻辑，你都应当使用**计算属性**。

#### 计算属性缓存vs方法

不同的是**计算属性是基于它们的响应式依赖进行缓存的**。只在**相关响应式依赖**发生改变时它们才会重新求值。这就意味着只要 `message` 还没有发生改变，多次访问 `reversedMessage` 计算属性会**立即返回之前的计算结果**，而不必再次执行函数。

这也同样意味着下面的计算属性**将不再更新**，因为 `Date.now()` 不是响应式依赖：【即**不依赖vue中data元素**】

```js
computed: {
  now: function () {
    return Date.now()
  }
}
```

我们为什么需要缓存？假设我们有一个性能开销比较大的计算属性 **A**，它需要遍历一个巨大的数组并做大量的计算。然后我们可能有**其他的计算属性依赖于 A**【优化性能】。如果没有缓存，我们将不可避免的多次执行 **A** 的 getter！如果你不希望有缓存【较少空间占用】，请用方法来替代。

#### 计算属性vs侦听属性

### v-if

#### [用key管理可复用的元素](https://cn.vuejs.org/v2/guide/conditional.html#%E7%94%A8-key-%E7%AE%A1%E7%90%86%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E5%85%83%E7%B4%A0)

##### v-if  v-else会复用元素

vue提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 `key` attribute 即可：

```vue
<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>
```

现在，每次切换时，输入框都将被重新渲染。请看：

注意，**`<label>` 元素仍然会被高效地复用**，因为它们没有添加 `key` attribute。【**为啥都是复用，又没有v-bind？？**】

### v-show

带有 `v-show` 的元素始终会被渲染并保留在 DOM 中。`v-show` 只是简单地切换元素的 CSS property `display`。

注意，`v-show` 不支持 `<template>` 元素，也不支持 `v-else`。

### v-if vs v-show

##### v-if 

v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被**销毁和重建**。v-if 也是**惰性的**：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

##### v-show

v-show 不管初始条件是什么，元素**总是会被渲染**，并且只是简单地基于display进行切换。

##### 总结

一般来说，`v-if` 有更高的**切换开销**，而 `v-show` 有更高的**初始渲染开销**。因此，如果需要**频繁切换**，使用 v-show；如果在运行时条件**很少改变**，使用 v-if较好。

### v-for

#### 简单遍历的第二个参数

```vue
 <li v-for="(item, index) in items">
  {{ index + 1}} - {{ item }}
  </li>
```

#### 遍历对象的 property所用的参数

参数分别时value、name、index

```
<div v-for="(value, name, index) in object">
  {{ index }}. {{ name }}: {{ value }}
</div>
```

#### v-for的key

建议尽可能在使用 `v-for` 时提供 `key` attribute，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

因为它**是 Vue 识别节点的一个通用机制**，`key` 并不仅与 `v-for` 特别关联。后面我们将在指南中看到，它还具有其它用途。

不要使用对象或数组之类的非基本类型值作为 `v-for` 的 `key`。请用**字符串或数值类型**的值。

#### [key API](https://cn.vuejs.org/v2/api/#key)

`key` 的特殊 attribute 主要**用在 Vue 的虚拟 DOM 算法**，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度**减少动态元素**并且尽可能的**尝试就地修改/复用相同类型元素**的算法。而使用 key 时，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

有相同父元素的子元素**必须有**独特的 key。重复的 key 会造成渲染错误。

### 事件修饰符

在事件处理程序中调用 `event.preventDefault()` 或 `event.stopPropagation()` 是非常常见的需求。尽管我们可以在方法中轻松实现这点，但**更好的方式是**：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。

为了解决这个问题，Vue.js 为 `v-on` 提供了**事件修饰符**。之前提过，修饰符是由点开头的指令后缀来表示的。

- `.stop`
- `.prevent`
- `.capture`
- `.self`
- `.once`
- `.passive`
- .once
- .passive

```vue
<!-- 阻止单击事件继续传播 -->
<a v-on:click.stop="doThis"></a>

<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>

<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>

<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>

<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 -->
<div v-on:click.capture="doThis">...</div>

<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>

不像其它只能对原生的 DOM 事件起作用的修饰符，.once 修饰符还能被用到自定义的组件事件上。如果你还没有阅读关于组件的文档，现在大可不必担心。
<!-- 点击事件将只会触发一次 -->
<a v-on:click.once="doThis"></a>

.passive 修饰符尤其能够提升移动端的性能。
<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->
<!-- 而不会等待 `onScroll` 完成  -->
<!-- 这其中包含 `event.preventDefault()` 的情况 -->
<div v-on:scroll.passive="onScroll">...</div>
```

使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `v-on:click.prevent.self` 会阻止**所有的点击**，而 `v-on:click.self.prevent` 只会阻止对元素自身的点击。

### 按键修饰符

在监听键盘事件时，我们经常需要检查详细的按键。Vue 允许为 `v-on` 在监听键盘事件时添加按键修饰符：

```vue
<!-- 只有在 `key` 是 `Enter` 时调用 `vm.submit()` -->
<input v-on:keyup.enter="submit">
```

你可以直接将 [`KeyboardEvent.key`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values) 暴露的任意有效按键名转换为 kebab-case 来作为修饰符。

```vue
<input v-on:keyup.page-down="onPageDown("要触发的函数")">
```

在上述示例中，处理函数只会在 `$event.key` 等于 `PageDown` 时被调用。

### v-modle

`v-model` 本质上是**语法糖**

#### 啥意思？

在文本区域插值 (`<textarea>{{text}}</textarea>`) 并不会生效，应用 `v-model` 来代替。

#### label的for属性

label不添加for属性，点了没反应

增加for属性后，点label，就可以选中input控件

## D16 10.31

### props数据验证

![image-20211031104934147](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211031104934147.png)

### $children[$refs]与$parent

#### $children的缺陷

通过$children访问子组件时，是一个数组类型，访问其中的子组件必须通过索引值。

但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。

有时候，我们想明确获取其中一个特定的组件，这个时候就可以使用$refs

#### $refs的使用

$refs和ref指令通常是一起使用的。

首先，我们通过**ref给某一个子组件绑定一个特定的ID**。

其次，通过this.$refs.ID就可以访问到该组件了。

#### $parent

如果我们想在子组件中直接访问父组件，可以通过$parent

注意事项：

尽管在Vue开发中，我们允许通过$parent来访问父组件，但是在真实开发中尽量不要这样做。

子组件应该尽量避免直接访问父组件的数据，因为这样**耦合度太高了**。

如果我们将子组件放在**另外一个组件之内，很可能该父组件没有对应的属性**【**较小耦合度**】，往往会引起问题。

另外，更不好做的是通过$parent直接修改父组件的**状态**，那么父组件中的状态将变得飘忽不定，很不利于我的调试和维护。

#### 非父子组件通信

在Vue2.x中，有一种方案是通过**中央事件总线**，也就是一个中介来完成。

但是这种方案和直接使用Vuex的状态管理方案还是逊色很多。

### slot

#### 编译作用域

![image-20211031110913461](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211031110913461.png)

#### 作用

组件的插槽也是为了让我们封装的组件**更具有扩展性**。

让使用者可以决定组件内部的一些内容到底**展示什么**。

最好的封装方式就是**将共性抽取到组件中，将个性【不同】暴露为插槽**

#### 匿名插槽

只有一个，给值就有，不给就默认

#### 具名插槽

有多个插槽是要分清哪个是哪个，所以药给每个插槽起名字 

```vue
<slot name='myslot'></slot>
```

#### 作用域插槽

父组件**替换插槽的标签**，但是**内容由子组件来提供**。【即修改了插槽的作用域，将本来应该在父组件中使用父组件数据编译转化为使用子组件数据编译】

子组件中

```vue
<slot :data="languages"></slot>
```

父组件中

```vue
<!-- 通过   slot-scope="slotProps"  命令拿到插槽绑定的数据 -->
<template slot-scope="slotProps">
	<ul>
		<li v-for="item in slotProps.data">{{item}}</li>
	</ul>
</template>
```



```vue
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <title>10-作用域插槽</title>
</head>

<body>
  <div id="app">
    <!-- 同样的数据，想要不同的展示方式 -->
    <!-- 列展示 -->
    <cpn>
      <!-- 通过   slot-scope="slotProps"  命令拿到插槽绑定的数据 -->
      <template slot-scope="slotProps">
        <ul>
          <li v-for="item in slotProps.data">{{item}}</li>
        </ul>
      </template>
    </cpn>
    <!-- 一行展示 -->
    <cpn>
      <template slot-scope="slotProps">
        <h2>{{slotProps.data.join('-')}}</h2>
      </template>
    </cpn>
  </div>
  <template id="cpn">
    <div>
      <!-- 这个插槽绑定的数据是本组件【子组件】中的数据 -->
      <slot :data="languages"></slot>
    </div>
  </template>
  <script src="../js/vue.js"></script>
  <script>
    const cpn = Vue.extend({
      template: '#cpn',
      data() {
        return {
          languages: ['Java', 'Python', 'JavaScript', 'TypeScript', 'C++', 'OC']
        }
      }
    })

    const app = new Vue({
      el: '#app',
      components: {
        cpn
      }
    })
  </script>

</body>

</html>
```

### 函数有自己的作用域

### 模块化

#### ES5的模块化

#### CommonJS

#### ES6的模块化

加上 type="module" 之后等于将引入的js文件作为模块，而**模块有自己的作用域**

```
<script src="info.js" type="module"></script>
```

export default  不允许存在多个

### webpack

老师的node版本是10.13.0

![image-20211102093155590](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211102093155590.png)

## [修改伪元素属性](https://www.jb51.net/article/81984.htm)

```js
// CSS代码
#myId:before {
content: "hello world!";
display: block;
width: 100px;
height: 100px;
background: red;
}
// HTML代码
<div id="myId"></div>
// JS代码
var myIdElement = document.getElementById("myId");
var beforeStyle = window.getComputedStyle(myIdElement, ":before");
console.log(beforeStyle); // [CSSStyleDeclaration Object]
console.log(beforeStyle.width); // 100px
console.log(beforeStyle.getPropertyValue("width")); // 100px
console.log(beforeStyle.content); // "hello world!"
```

## coderwhy数据结构与算法

### 数组缺点

1数组进行插入操作时,效率比较低

2.数组进行查找操作的效率

1)如果是基于索引进行查找操作效率非常高

2)基于内容去查找(比如name='why)

3、数组进行删除操作,效率也不高

4、修改效率也不高

### 哈希表

哈希表通常是基于数组进行实现的,但是相对于数组,它也很多的**优势**:
它可以提供非常快速的插入-删除查找操作
无论多少数据,插入和删除值需要接近常量的时间:即O(1)的时间级实际上,只需要几个机器指令即可完成
哈希表的速度比树还要快,基本可以瞬间查找到想要的元素
哈希表相对于树来说编码要容易很多!
哈希表相对于数组的一些**不足**:
哈希表中的数据是没有顺序的,所以不能以一种固定的方式(比如从小到大)来遍历其中的元素
通常情况下,哈希表中的key是不允许重复的,不能放置相同的key,用于保存不同的元素.

#### 哈希化

哈希化:将大数字转化成数组范围内下标的过程,我们就称之为哈希化.【通常是取模（取余）】
哈希函数:通常我们会将单词转成大数字,大数字在进行哈希化的代码实现放在一个函数中,这个函数我们成为
哈希函数.
哈希表:最终将数据插入到的这个数组,对整个结构的封装,我们就称之为是一个哈希表

**但是**,我们还有问题需要解决:
	虽然,我们在一个100000的数组中,放5000个单词已经足够.
	但是通过哈希化后的下标值依然可能会重复,如何解决这种重复的问题呢?

#### 解决冲突的方法

##### 链地址法【多数情况

一个位置放一个链表【新数据插入到第一个位置】/数组

##### 开放地址法

寻找空白的位置放置元素，找新空白位置又分为三个方法

1. 线性探测

因为将它设置为nul可能会影响我们之后查询其他操作,所以通常删除一个位置的数据项时,我们可以将它进行特殊处
理(比如设置为-1).

当我们之后看到-1位置的数据项时,就知道查询时要继续查询,但是插入时这个位置可以放置数据.

缺点：【跟数组差不多了】

线性探测有一个比较严重的问题,就是聚集,什么是聚集呢?
比如我在没有任何数据的时候,插入的是22-23-24-25-26,那么意味着下标值:2-3-4-5-6的位置都有元素.
这种一连串填充单元就叫做聚集
聚集会影响哈希表的性能,无论是插入/查询/删除都会影响.
比如我们插入一个32,会发现连续的单元都不允许我们放置数据,并且在这个过程中我们需要探索多次
二次探测可以解决一部分这个问题,我们一起来看一看.

1. 二次探测

解决线性探测的问题

1. 再哈希法

第二次哈希化需要具备如下特点:
和第一个哈希函数不同.(不要再使用上一次的哈希函数了,不然结果还是原来的位置)
不能输出为0(否则,将没有步长.每次探测都是原地踏步,算法就进入了死循环)

其实,我们不用费脑细胞来设计了,计算机专家已经设计出一种工作很好的哈希函数:
stepSize = constant - (key - çonstant)
其中constant是质数,且小于数组的容量
例如: stepSize =5-(key % 5),满足需求,并且结果不可能为0.

### 霍纳法则

用于处理多项式，降低O(N)

![image-20211124100637296](C:\Users\11653\AppData\Roaming\Typora\typora-user-images\image-20211124100637296.png)

### 哈希表的实现

1、根据key获取索引值

目的:将数据插入到对应的位置

2、根据索引值取出bucket

1)如果桶不存在,创建桶,并且放置在该索引的位置

3、判断新增还是修改原来的值

- 如果已经有值了,那么就修改值
- 如果没有,执行后续的添加操作

4、新增操作

### 各数据结构优缺点

![image-20211124195532994](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211124195532994.png)

![image-20211124195605529](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211124195605529.png)

### 递归函数

会自自动返回,递归就是函数调用栈,会弹出完成的函数

函数压栈出栈

### 二叉树

#### 先序遍历

![image-20211125215943860](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211125215943860.png)

#### 中序遍历

#### 后序遍历

### 红黑树

二叉搜索树**为非平衡树**时的解决方法

非常难，红黑树搞明白，基本上数据结构就没啥大问题了； 

![image-20211126140918398](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211126140918398.png)

#### 红黑树的规则

![image-20211126141656513](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211126141656513.png)

#### 红黑树的相对平衡

![image-20211126141902685](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211126141902685.png)

#### 变色

![image-20211126143901850](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211126143901850.png)

#### 旋转

![image-20211126143920736](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211126143920736.png)

## Vue

### [vue 监听事件的修饰符](https://www.cnblogs.com/crazy-lc/p/12197621.html)

### props传递布尔值/数字

在自定义一个组件时，发现props中定义了一个type为Boolean的值，如何在父组件传递到子组件？

```js
props: {
    propA: {
        type: Boolean,
        default: false,
    }
```

初学者通常是是直接传递数值：

```vue
<comp propA="true"></comp>
```

实际上这样会导致它是以字符串 “true” 传下去。如果想传递一个实际的 Boolean值，需要使用 v-bind ，从而让它的值**被当作 JavaScript 表达式**计算：

```vue
<comp :propA="true"></comp>
```

数字同理

### [vue各阶段数据可使用情况](https://www.cnblogs.com/yaoyao-sun/p/10390575.html)

created时，可用data和prop中的数据。

computed的属性，当在mounted或者dom中使用到时，才会属性的执行代码。

最后是mouted，可使用前面的数据，并且此时才可以操作dom。

watch不会再创建阶段自动执行，除了添加立即执行这个配置项。

###  [填充 JavaScript 数组的 4种方式](https://baijiahao.baidu.com/s?id=1621925731894454838&wfr=spider&for=pc)

### vue 组件监听鼠标滚动事件

当需要组件模块化来渲染一个页面时，如果要监听当前组件的scroll事件，使用window.addEventListener('srcoll')是无效的，

所以对当前组件采用监听滚动事件。

如给当前div ref来获取当前的dom元素，

<div class="bd" ref="viewBox"></div>
在mounted中，监听当前的滚动事件，然后进行相应的操作

```vue
   this.$nextTick(function() {
      // 监听当前组件的滚动事件
      this.box = this.$refs.viewBox;
      this.box.addEventListener('scroll', ()=> {
        if(this.$refs.viewBox.scrollTop > 0) {   //显示下拉loading，展示更多数据
          this.handleScroll();
        }
      },false)
    });
```

#### 解决以下vue组件的监听问题

```vue
<template>
  <div>
    <div class="drag" id="draggg">
    </div>
    <div>
      <slot>
      </slot>
    </div>
  </div>
</template>
<script>
export default {
  data() {
    return {};
  },
  props: {
    dragCss: { type: String, default: "" },
    // dragCss: { type: Object, default: "" },
  },
  components: {},
  created() {},
  mounted() {
    // let dragDiv = document.querySelector(".drag");
    let dragDiv = document.querySelector("#draggg");
    console.log(dragDiv);
    let clickBox = dragDiv.parentElement;
    //其他地方还有一个drag，导致这的parentElement是另外一个，拖拉失效了，就算是class，也容易出问题；所以这需要给一个动态的id或者class，多个class出问题
    console.log(clickBox);
    clickBox.onmousedown = (e) => {
      console.log(e);
      let mouseDownX = e.clientX;
      let clickBoxLeft = clickBox.offsetLeft;
      let clickBoxWeight = clickBox.offsetWidth;

      let direction;
      if (mouseDownX < clickBoxLeft + 30) {
        direction = "left";
        console.log(direction);
      }

      console.log(direction);
      document.onclick = (e) => {
        console.log(e);
        console.log(direction);
      };
      // 加节流！！！！！！
      // 移动鼠标时
      document.onmousemove = function (e) {
        console.log(e);
        let xx = e.clientX;
        clickBox.style.width = clickBoxWeight + mouseDownX - xx + "px";
        clickBox.style.left = xx + "px";
        dragDiv.classList.add("drag_div_t");
        if (e.preventDefault) {
          e.preventDefault();
          //e是MouseEvent，加上之后拖动div时不会选中文本，可以用来防止复制
        }
        if (direction === "left") {
          console.log(e);
          let xx = e.clientX;
          clickBox.style.width = clickBoxWeight + mouseDownX - xx + "px";
          clickBox.style.left = xx + "px";
          dragDiv.classList.add("drag_div_t");
          if (e.preventDefault) {
            e.preventDefault();
            //e是MouseEvent，加上之后拖动div时不会选中文本，可以用来防止复制
          }
        }
        //return false; //这里为了避免抖动
      };
      document.onmouseup = function () {
        document.onmousemove = null;
        document.onmouseup = null;
        dragDiv.classList.remove("drag_div_t");
        direction = null;
      };
      // if (e.preventDefault) {
      //   e.preventDefault();
      // }  有这一行之后，文本不能编辑了
    };
  },
  methods: {
    dragDiv(e) {
      console.log(e);
    },
  },
};
</script>
<style scoped>
.outer2 {
  position: absolute;
  right: 0px;
  top: 0;
  bottom: 0;
  background-color: rgb(23, 95, 47);
  width: 24%;
}
.drag {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  /* background-color: red; */
  width: 5px;
  z-index: 999;
}
.drag:hover {
  cursor: w-resize;
  background-color: #2a88dd;
  filter: blur(6px);
}
.body {
  position: absolute;
  left: 15px;
  top: 0;
  bottom: 0;
  background-color: rgb(201, 201, 201);
}
.drag_div_t {
  cursor: w-resize;
  background-color: #2a88dd;
  filter: blur(6px);
}
</style>

```

使用clickBox.onmousemove()

```vue
<template>
  <div>
    <div class="drag" id="draggg" ref="viewBox">
    </div>
    <div>
      <slot>
      </slot>
    </div>
  </div>
</template>
<script>
export default {
  data() {
    return {};
  },
  props: {
    dragCss: { type: String, default: "" },
    // dragCss: { type: Object, default: "" },
  },
  components: {},
  created() {},
  mounted() {
    // this.box = this.$refs.viewBox;
    // this.box.addEventListener(
    //   "onmousedown",
    //   () => {
    //     if (this.$refs.viewBox.scrollTop > 0) {
    //       //显示下拉loading，展示更多数据
    //       this.handleScroll();
    //     }
    //   },
    //   false
    // );
    // ————————————————————————————————————————————
    // let dragDiv = document.querySelector(".drag");
    let dragDiv = document.querySelector("#draggg");
    console.log(dragDiv);
    let clickBox = dragDiv.parentElement;
    //其他地方还有一个drag，导致这的parentElement是另外一个，拖拉失效了，就算是class，也容易出问题；所以这需要给一个动态的id或者class，多个class出问题
    console.log(clickBox);
    clickBox.onmousedown = (e) => {
      console.log(e);
      let mouseDownX = e.clientX;
      let clickBoxLeft = clickBox.offsetLeft;
      let clickBoxWeight = clickBox.offsetWidth;

      let direction;
      if (mouseDownX < clickBoxLeft + 30) {
        direction = "left";
        console.log(direction);
      }

      console.log(direction);
      document.onclick = (e) => {
        console.log(e);
        console.log(direction);
      };
      // 加节流！！！！！！
      // 移动鼠标时
      document.onmousemove = function (e) {
        console.log(e);
        let xx = e.clientX;
        clickBox.style.width = clickBoxWeight + mouseDownX - xx + "px";
        clickBox.style.left = xx + "px";
        dragDiv.classList.add("drag_div_t");
        if (e.preventDefault) {
          e.preventDefault();
          //e是MouseEvent，加上之后拖动div时不会选中文本，可以用来防止复制
        }
        if (direction === "left") {
          console.log(e);
          let xx = e.clientX;
          clickBox.style.width = clickBoxWeight + mouseDownX - xx + "px";
          clickBox.style.left = xx + "px";
          dragDiv.classList.add("drag_div_t");
          if (e.preventDefault) {
            e.preventDefault();
            //e是MouseEvent，加上之后拖动div时不会选中文本，可以用来防止复制
          }
        }
        //return false; //这里为了避免抖动
      };
      document.onmouseup = function () {
        document.onmousemove = null;
        document.onmouseup = null;
        dragDiv.classList.remove("drag_div_t");
        direction = null;
      };
      // if (e.preventDefault) {
      //   e.preventDefault();
      // }  有这一行之后，文本不能编辑了
    };
  },
  methods: {
    dragDiv(e) {
      console.log(e);
    },
  },
};
</script>
<style scoped>
.outer2 {
  position: absolute;
  right: 0px;
  top: 0;
  bottom: 0;
  background-color: rgb(23, 95, 47);
  width: 24%;
}
.drag {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  /* background-color: red; */
  width: 5px;
  z-index: 999;
}
.drag:hover {
  cursor: w-resize;
  background-color: #2a88dd;
  filter: blur(6px);
}
.body {
  position: absolute;
  left: 15px;
  top: 0;
  bottom: 0;
  background-color: rgb(201, 201, 201);
}
.drag_div_t {
  cursor: w-resize;
  background-color: #2a88dd;
  filter: blur(6px);
}
</style>

```



### coderwhy-vue

### vuex

![image-20211202204659785](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211202204659785.png)

#### 操作流程

组件可以直接修改State，但不推荐，因为Devtools在Mutations阶段记录谁操作了State中数据，直接修改State无法记录是哪个组件进行了操作；(**跟踪组件对state中数据的提交状态**)

组件可以直接在Mutations中修改State，但是Mutations只支持同步操作【也可以异步操作，但是异步了的话vue.js-devtools就无法跟踪了】，如果需要异步操作需要在Actions中进行。

#### Vuex的使用

#### 响应规则

![image-20211202223414965](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211202223414965.png)

**只有state中本身就存有的数据才是响应式的**，添加就没有了【需要使用其他方法 Vue.set(） Vue.delete()】

![image-20211202234405983](C:\Users\Syh\AppData\Roaming\Typora\typora-user-images\image-20211202234405983.png)

#### State

**修改state的唯一途径是通过mutation**

state中的数据是响应式的，即**当state中数据发生改变时，vue组件自动更新**

这些属性都会被加入到响应式系统中而响应式系统会监听属性的变化当属性发生变化时,会通知所有界面中用到该属性的地方,让界面发生刷新。

##### 关联-哪些数组的方法是响应式的！！！？？？

#### Getters

存放**计算属性**，当需要拿到计算后的State数据时，可以用这个

1.getter中

```js
powerCounter(state){
	return state.counter * state.counter
}
stuBiggerThan20(state){
	return state.student.filter(s=>s.age>20)
}
//如果想拿到年龄大于20的学生的个数
	//method 1,没水平
stuBiggerThan20Length(state){
	return state.student.filter(s=>s.age>20).length
}
	//方法2，高级！！！
stuBiggerThan20Length（state,getters）{ 
	return getters.stuBiggerThan20.length   
}
//获取年龄大于  X 的人
stuBiggerThanX（state,getters）{ 
	return function(age){
	return state.student.filter(s=>s.age>X)
	} 
	//修改上述匿名函数为箭头函数
	return age=>state.student.filter(s=>s.age>X)
}
```

2.组件中

```js
$state.getter.powerCounter
```

#### Mutation

官方建议mutation的风格,意义何在？？？【把方法名称**抽离成常量**】

```js
import {TEST} from "./xx.js"
['TEST']{
	do sth.
}
```

xx.js

```js
export const TEST = "functionName"
```

##### 关联- vue中文件的导出导入

- 1、文件是export default，则导入可以import customName form xx.xx
- 2、文件时export const XX = something，则只能import ｛XX｝ form xx.xx

1.在mutation或者action中添加函数修改state中文件，如：

```js
increase(state){
	state.counter ++
}
//增加指定数
increaseNum(state,count){
	state.counter += count
}
//特殊的提交方式
increaseNum2(state,payload){
	console.log(payload)   //{type:"increaseNum2",count}
	state.count += payload.count
}
```

2.组件methods中调用store下mutation中对应函数

```js
this.$store.commit("increase")
this.$store.commit("increaseNum",count)  //称为payload，负载
//特殊的提交方式   用处是啥？？？  【可携带回调函数！！！】
this.$store.commit({
	type:"increaseNum2",
	count
})
```

#### Action(context)

1.action中

```js
//1.常规操作
aupdateInfo(context,arg){
	setTimeOut({
		console.log(arg)
		console.log(context)  //store
		context.commit('updateInfo',arg) //异步时调用commit执行mutation中对应函数；
	})
}
//2.带回调函数，此处用到了上边的【特殊的提交方式】
aupdateInfo2(context,payload){
	console.log(payload)  //注意2.1和2.2的区别
    setTimeout(()=>{
        context.commit("updateInfo")
        console.log(payload)
        resolve("需要回调传给.then的值-比如成功状态等")
    },1000)
}
3.action中返回new Promise！！！
aupdateInfo3(context,arg){
    return new Promise(resolve,reject)=>{
        setTimeout(()=>{
            context.commit("updateInfo")  //写在promise外也行，就是如果真的要传递成功状态的话，应该是写在里边比较合适（可以使用reject()处理失败情况），大概是这样，不太确定！！！？？？
            console.log(arg)
            resolve("需要回调传给.then的值-比如成功状态等")
        },1000)
    }
}
```

2.组件中

```
1.常规
functionName(arg){
	this.$store.dispatch('aupdateInfo',arg)  //arg:payload
}
//2.特殊的提交方式   用处是啥？？？  【可携带回调函数！！！】
//2.1全部写到一个payload里【不一定能成！！】
this.$store.dispatch({
	type:"aupdateInfo2"  //function name in action
	count：arg =>console.log(arg)
	message:"传递的消息"
})
//2.2分开函数名和参数
this.$store.dispatch("aupdateInfo2",{
	count：arg =>console.log(arg)
	message:"传递的消息"
})
//3、带then的回调【action中返回promise】，此时不需要在payload中写回调函数了，直接返回promise了！！
this.$store.dispatch("aupdateInfo3","传递的消息"})
	.then(res => console.log(res))  
```

#### Module

vue建议使用单一状态树，即一个项目中只有一个State

为了解决应用过大，进而导致的state中变量太多的问题，使用Module对state进行分区

### 路由[vue-router](https://router.vuejs.org/zh/guide/advanced/navigation-guards.html#%E5%85%A8%E5%B1%80%E5%89%8D%E7%BD%AE%E5%AE%88%E5%8D%AB)

Part1、基本

1. 动态路由
2. 嵌套路由
3. 编程式导航
4. 路由传参
5. history模式

Part2、进阶级别

1. 导航守卫
2. 路由懒加载

#### 导航守卫

全局前置守卫
全局解析守卫
全局后置钩子
路由独享的守卫
组件内的守卫
完整的导航解析流程

### props

default默认值为数组或对象时,使用函数。其他类型直接`default：xx`

### 路由跳转传递参数

两种方式

1. 动态路由
2. params

### keep-alive

保持vue组件存活，跳转时回调`deactived`，重新进入时回调`actived`！！！

没有添加keep-alive的组件跳转即销毁，但是setTimeout函数还在执行，可在destory中回调【clearInterval】，`或者`在路由里设置单个路由的beforeEach(from,to,next())

封装组件中的computed【GoodListItem.vue】

### vue的filter【过滤器】

vue3没有了，推荐用computed！！！？？？

### mixin

vue组件export中的混用，可混用【data、methods、mounted等，	基本都能混用！！！】

### js 获取当前元素距离窗口的距离

getBoundingClientRect()获取的是div距离窗口`左边`和`顶部`的距离

```js
let domToTop = dom.getBoundingClientRect().top  // dom 的顶边到视口顶部的距离
let domToLeft = dom.getBoundingClientRect().left // dom 的左边到视口左边的距离
let domToBottom = dom.getBoundingClientRect().bottom // dom 的底边到视口顶部的距离
let domToRight = dom.getBoundingClientRect().right // dom 的右边到视口左边的距离
```

####  Element.scrollLeft

**`Element.scrollLeft`** 属性可以读取或`设置`元素滚动条到`元素左边`的距离。【其自身左边】

## placeholder

```js
function getRestTime(p) {
  let flag = p;
  //if(!p){  //有弊端，传入0时候当成false！！！
  if (p === undefined) {
    let url = window.location.href;
    let myRe = /\?p.*?&/; //以?p开头，以&结尾的字符串
    let currentP = myRe.exec(url)[0];
    p = currentP.substring(3, currentP.length - 1) * 1;
  } else if (p < 0 || typeof p != "number") {
    console.log(p);
    return "别闹！";
  }

  let ul = document.querySelector(".list-box");
  let result = 0;

  for (let i = p; i < ul.childNodes.length; i++) {
    //console.log(ul.childNodes[i])
    let duration = ul.childNodes[i].querySelector(".duration").innerText;
    let durationTime =
      duration.substring(0, 1) == "0"
        ? duration.substring(1, 2)
        : duration.substring(0, 2);
    result += durationTime * 1 + 1;
  }
  //console.log(flag)
  return flag!==undefined
    ? `指定p【${p}p】：距离结束【${ul.childNodes.length}p】不超过${result}分钟~~`
    : `本p【${p}p】：距离结束【${ul.childNodes.length}p】还有不超过${result}分钟~~`;
}
```

### $nextTick()

2.1.0 起新增：如果没有提供回调且在支持 Promise 的环境中，则返回一个 Promise。请注意 Vue 不自带 Promise 的 polyfill，所以如果你的目标浏览器不原生支持 Promise (IE：你们都看我干嘛)，你得自己提供 polyfill。

```js
// 修改数据
vm.msg = 'Hello'
// DOM 还没有更新
Vue.nextTick(function () {
  // DOM 更新了
})

// 作为一个 Promise 使用 (2.1.0 起新增，详见接下来的提示)
Vue.nextTick()
  .then(function () {
    // DOM 更新了
})

```

### VM【虚拟Dom】以及diff算法！！！[？？？](https://juejin.cn/post/6844903895467032589#comment)

LocalSto
