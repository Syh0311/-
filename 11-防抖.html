<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>防抖</title>
    <style>
        #fangkuai {
            position: absolute;
            /* top: 0; */
            margin: 0 auto;
            width: 300px;
            height: 300px;
            background-color: antiquewhite;
        }
    </style>
</head>

<body>
    <h1>debounce分为 非立即执行版 和 立即执行版 两种</h1>
    <h2>平常用的大多数为 非立即执行版【需要一个timer变量】</br>
        立即执行版较为复杂，另需一个辅助变量帮助理解【共两个变量】</h2>
    <h3>
        非立即执行版：较为简单；</br>
        立即执行版：【总结：我杀了我自己（timer杀timer）】
    </h3>

    <input id="ipt" type="text">
    <div id="fangkuai"></div>

</body>
<script>
    function showInnertext() {
        console.log(this.value);
        console.log(1);
    }
    let ipt = document.getElementById('ipt')
    // ipt.addEventListener('change', showInnertext)
    ipt.onchange = function () {
        console.log(this.value);
    }

    function move(A) {
        console.log(A);
    }
    let fangkuai = document.getElementById('fangkuai')
    // fangkuai.onmousemove = debounceFinal(move('SYH'), 1000)
    fangkuai.onmousemove = debounce(move, 1000)
    // fangkuai.onmousemove = debounceRightnow(move, 1000)

    // 非立即执行版【停下之后，再给定时间内不再调用，就执行函数】
    function debounce(func, time) {
        let timer;
        console.log(this);
        return function () {
            // console.log(this);  //回调函数（返回函数）的this指向问题
            if (timer) clearTimeout(timer);
            timer = setTimeout(() => {
                // func()
                console.log(11);
            }, time);
        }
    }
    // 立即执行版【执行完之后，不停就不再继续执行】
    function debounceRightnow(func, wait) {
        let timeout  //闭包
        return function () {
            if (timeout) clearTimeout(timeout);
            let callNow = !timeout;
            timeout = setTimeout(() => {
                timeout = null;//【总结：我杀了我自己】timeout一开始是1（或2、或3，setTimeout的id值），过wait时间后变为null，如果wait时间内不调用函数，再调用函数时候timeout是null,则callNow是false，不再执行
            }, wait)
            if (callNow) func()
        }
    }
    // 结合版【可选择版】
    /**
     * @desc 函数防抖
     * @param func 函数
     * @param wait 延迟执行毫秒数
     * @param immediate true 表立即执行，false 表非立即执行
     */
    function debounceFinal(func, wait, immediate) {
        let timeout;
        return function () {
            let context = this;
            let args = arguments;
            console.log(args);
            if (timeout) clearTimeout(timeout);
            if (immediate) {
                var callNow = !timeout;
                timeout = setTimeout(() => {
                    timeout = null;
                }, wait)
                if (callNow) func.apply(context, args)
            }
            else {
                timeout = setTimeout(function () {
                    func.apply(context, args)
                }, wait);
            }
        }
    }
</script>

</html>