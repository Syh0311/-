### 第16题：参考答案：

CSS属性 `touch-action` 用于设置触摸屏用户如何操纵元素的区域(例如，浏览器内置的缩放功能)。

最简单方法是：

```
html{
 touch-action: none;
 touch-action: pan-y;
}
```

还可以直接指定对应元素的宽度和overflow：

```
html{
 width: 100vw;
 overflow-x: hidden;
}
```

### 第17题：如何检测浏览器所支持的最小字体大小？

使用 JS 设置 DOM 的字体为某一个值，然后再取出来，如果值设置成功，就说明支持。

### 第18题：Js 动画与 CSS 动画区别及相应实现

参考答案：

- CSS3 的动画的优点
  - 在性能上会稍微好一些，浏览器会对 CSS3 的动画做一些优化
  - 代码相对简单
- 缺点
  - 在动画控制上不够灵活
  - 兼容性不好

JavaScript 的动画正好弥补了这两个缺点，控制能力很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6，并且功能强大。对于一些复杂控制的动画，使用 javascript 会比较靠谱。而在实现一些小的交互动效的时候，就多考虑考虑 CSS 吧

### 第19题：IconFont 的原理是什么

### 第20题：css sprites是什么，怎么使用？

#### 是什么

CSS Sprites是一种网页图片应用处理方式，就是把网页中一些背景图片整合到一张图片文件中，再利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位。

#### 优点

其优点在于：

- 减少网页的http请求，提高性能，这也是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；
- 减少图片的字节：多张图片合并成1张图片的字节小于多张图片的字节总和；
- 减少了命名困扰：只需对一张集合的图片命名，不需要对每一个小元素进行命名提高制作效率；
- 更换风格方便：只需要在一张或少张图片上修改图片的颜色或样式，整个网页的风格就可以改变，维护起来更加方便。

#### 缺点

诚然CSS Sprites是如此的强大，但是也存在一些不可忽视的缺点：

- 图片合成比较麻烦；
- 背景设置时，需要得到每一个背景单元的精确位置；
- 维护合成图片时，最好只是往下加图片，而不要更改已有图片。

### 第21题：display:none与visibility:hidden 有什么区别？

#### 表现上

- display:none是彻底消失，不在文档流中占位，浏览器也不会解析该元素；
- visibility:hidden是视觉上消失了，可以理解为透明度为0的效果，在文档流中占位，浏览器会解析该元素；

#### 性能上

- 使用visibility:hidden比display:none性能上要好，display:none切换显示时，页面产生回流（当页面中的一部分元素需要改变规模尺寸、布局、显示隐藏等，页面重新构建，此时就是回流。所有页面第一次加载时需要产生一次回流），而visibility切换是否显示时则不会引起回流。

###  [第22题：你知道哪些css模块化的方案？](https://fe.ecool.fun/topic/0bb0b3a7-ed1b-41c0-a93e-7187b2aa85a8?orderBy=updateTime&order=desc&tagId=11)

目前主流的 css 模块化分为 css modules 和 css in js 两种方案。

#### css modules

> CSS Modules 指的是我们像 import js 一样去引入我们的 css 代码，代码中的每一个类名都是引入对象的一个属性, 编译时会将 css 类名 加上唯一 hash。

css module 需要 webpack 配置 css-loader 或者 scss-loader , module 为 true

```
{
    loader: 'css-loader',
    options: {
        modules: true, // 开启模块化
        localIdentName: '[path][name]-[local]-[hash:base64:5]'
    }
}
```

#### css in js

CSS-in-JS是一种技术（technique），而不是一个具体的库实现（library）。

简单来说CSS-in-JS就是将应用的CSS样式写在JavaScript文件里面，而不是独立为一些.css，.scss或者less之类的文件，这样你就可以在CSS中使用一些属于JS的诸如模块声明，变量定义，函数调用和条件判断等语言特性来提供灵活的可扩展的样式定义。

值得一提的是，虽然CSS-in-JS不是一种很新的技术，它当初的出现是因为一些component-based的Web框架（例如React，Vue和Angular）的逐渐流行，使得开发者也想将组件的CSS样式也一块封装到组件中去以解决原生CSS写法的一系列问题。

还有就是CSS-in-JS在React社区的热度是最高的，这是因为React本身不会管用户怎么去为组件定义样式的问题，而Vue和Angular都有属于框架自己的一套定义样式的方案。

### 第23题：html和css中的图片加载与渲染规则是什么样的？

`总结`：html会解析display:none  但css不会解析

根据[前面介绍](https://fe.ecool.fun/topic/5b612b6a-3828-4cd9-9de4-b05bb36a4e3d?orderBy=updateTime&order=desc&tagId=11)的浏览器加载和渲染机制，我们可以归纳为：

- <img>、<picture>和设置background-image的元素遇到display:none时，图片会加载但不会渲染
- <img>、<picture>和设置background-image的元素祖先元素设置display:none时，background-image不会渲染也不会加载，而img和picture引入的图片不会渲染但会加载
- <img>、<picture>和background-image引入相同路径相同图片文件名时，图片只会加载一次
- 样式文件中background-image引入的图片，如果匹配不到DOM元素，图片不会加载
- 伪类引入的background-image，比如:hover，只有当伪类被触发时，图片才会加载

### 第24题：CSS中的 “flex:1;” 是什么意思？

看[答案](https://fe.ecool.fun/topic/286f67d3-4e8d-48f5-962a-ed9cccc46335?orderBy=updateTime&order=desc&tagId=11)

flex是flex-grow   flex-shrink  flex-basis的集合

具体内容根据flex的定义不同

以上三个值的默认值是  1  1  0%

###  第25题：什么是BFC？

BFC：block formatting context，块级格式化上下文。

BFC是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

定位方案：

- 内部的Box会在垂直方向上一个接一个放置。
- Box垂直方向的距离由margin决定，属于同一个BFC的两个相邻Box的margin会发生重叠。
- 每个元素的margin box 的左边，与包含块border box的左边相接触。
- BFC的区域不会与float box重叠。
- BFC是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。
- 计算BFC的高度时，浮动元素也会参与计算。

满足下列条件之一就可触发BFC:

- 根元素，即html
- float的值不为none（默认）
- overflow的值不为visible（默认）
- display的值为table-cell, table-caption, inline-block, flex, 或者 inline-flex 中的其中一个
- position的值为absolute或fixed

###  第26题：分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

1. display:none: 会让元素完全从渲染树中消失，渲染的时候`不占据`任何空间, `不能点击`；
2. visibility: hidden:不会让元素从渲染树消失，渲染元素继续`占据`空间，只是内容不可见，`不能点击 `
3. opacity: 0: 不会让元素从渲染树消失，渲染元素继续`占据`空间，只是内容不可见，`可以点击`

### 第27题：Atom CSS 是什么？

一个类只干一件事  之后使用时候只写类名就可以

```css
.w-full{
  width:100%;
}
.h-full{
  height:100%;
}
```

### 第28题：[CSS中的1像素问题是什么？有哪些解决方案？](https://www.jianshu.com/p/7e63f5a32636)

#### viewport + rem 实现

同时通过设置对应viewport的rem基准值，这种方式就可以像以前一样轻松愉快的写1px了。
 在devicePixelRatio = 2 时【一个逻辑像素，px等于收集屏幕上2个物理像素】，输出viewport：



```html
<meta name="viewport" content="initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no">
```

在devicePixelRatio = 3 时，输出viewport：



```html
<meta name="viewport" content="initial-scale=0.3333333333333333, maximum-scale=0.3333333333333333, minimum-scale=0.3333333333333333, user-scalable=no">
```

这种兼容方案相对比较完美，适合新的项目，老的项目修改成本过大。

#### 伪类 + transform 实现  最优解

原理是

1. 把原先元素的 border 去掉，
2. 然后利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半，
3. 原先的元素相对定位，新做的 border 绝对定位。

唯一的缺陷是，`对于已使用伪元素的元素要多嵌套一个无用元素`。具体的实现如下：

```css
.scale-1px{
  position: relative;
  margin-bottom: 20px;
  border:none;
}
.scale-1px:after{
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  border: 1px solid #000;

  box-sizing: border-box;
  width: 200%;
  height: 200%;

  transform: scale(0.5);
}
```

### 第29题：css加载会造成阻塞吗？

浏览器渲染的流程如下：

- HTML解析文件，生成DOM Tree，解析CSS文件生成CSSOM Tree
- 将Dom Tree和CSSOM Tree结合，生成Render Tree(渲染树)
- 根据Render Tree渲染绘制，将像素渲染到屏幕上。

从流程我们可以看出来:

- DOM解析和CSS解析是两个并行的进程，所以这也解释了为什么CSS加载不会阻塞DOM的解析。
- 然而，由于Render Tree是依赖于DOM Tree和CSSOM Tree的，所以他必须等待到CSSOM Tree构建完成，也就是CSS资源加载完成(或者CSS资源加载失败)后，才能开始渲染。因此，CSS加载是会阻塞Dom的渲染的。
- 由于js可能会操作之前的Dom节点和css样式，因此浏览器会维持html中css和js的顺序。因此，样式表会在后面的js执行前先加载执行完毕。所以css会阻塞后面js的执行。

### 第32题：style标签写在body后与body前有什么区别？

页面加载自上而下 当然是先加载样式。

写在body标签后由于浏览器以逐行方式对HTML文档进行解析，当解析到写在尾部的样式表（外联或写在style标签）会导致浏览器停止之前的渲染，等待加载且解析样式表完成之后重新渲染，在windows的IE下可能会出现FOUC现象（即样式失效导致的页面闪烁问题）



1. 渲染机制的区别，在body前是已经把样式浏览一遍，到了对应标签直接，渲染样式。显示快。
2. 在body后，是浏览器已经把标签浏览了，但基于没有样式，显示的不完全，再把body后的样式表，扫描后，在成为真正的样式。会慢，遇到大型网站，效果更差，这都基于浏览器从上而小的浏览机制导致的。

### 第33题：两个同级的相邻元素之间，有看不见的空白间隔，是什么原因引起的？有什么解决办法？

一般是行内元素  之间有空白



行框的排列会受到`中间空白`（回车空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。

解决方法：

- 相邻元素代码代码全部写在一排
- 浮动元素，float:left;
- 在父级元素中用font-size:0;

### 第35题：::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用

- 单冒号(:)用于CSS3`伪类`，双冒号(::)用于CSS3`伪元素`。
- ::before就是以一个`子元素的存在`，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。

:before 和 :after 这两个伪元素，是在CSS2.1里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着Web的进化，在CSS3的规范里，伪元素的语法被修改成使用双冒号，成为::before ::after

### 第37题：CSS优化、提高性能的方法有哪些？

- 避免过度约束
- 避免后代选择符
- 避免链式选择符
- 使用紧凑的语法
- 避免`不必要的命名空间`
- 避免`不必要的重复`
- 最好使用表示语义的名字。一个好的类名应该是描述他是什么而不是像什么
- `避免！important`，可以选择其他选择器
- 尽可能的精简规则，你可以`合并不同类里的重复规则`

### 第38题：margin和padding分别适合什么场景使用？

何时使用margin：

- 需要在border外侧添加空白
- 空白处不需要背景色
- 上下相连的两个盒子之间的空白，需要相互抵消时。

何时使用padding：

- 需要在border内侧添加空白
- 空白处需要背景颜色
- 上下相连的两个盒子的空白，希望为两者之和。

### 第40题：为什么会出现浮动？什么时候需要清除浮动？清除浮动的方式有哪些？

浮动元素碰到包含它的边框或者浮动元素的边框停留。由于浮动元素不在文档流中，所以文档流的块框表现得就像浮动框不存在一样。浮动元素会漂浮在文档流的块框上。

浮动带来的问题：

- 父元素的高度无法被撑开，影响与父元素同级的元素
- 与浮动元素同级的非浮动元素（内联元素）会跟随其后
- 若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构。

清除浮动的方式：

- 父级div定义height
- 最后一个浮动元素后加空div标签 并添加样式clear:both。
- 包含浮动元素的父标签添加样式overflow为hidden或auto。
- 父级div定义zoom

### 第41题：CSS3新增伪类有那些？

- p:first-of-type 选择属于其父元素的首个元素
- p:last-of-type 选择属于其父元素的最后元素
- p:only-of-type 选择属于其父元素唯一的元素
- p:only-child 选择属于其父元素的唯一子元素
- p:nth-child(2) 选择属于其父元素的第二个子元素
- :enabled :disabled 表单控件的禁用状态。
- :checked 单选框或复选框被选中。

###  第42题：CSS中，box-sizing属性值有什么用？

用来控制元素的盒子模型的解析模式，默认为`content-box`

- context-box：W3C的标准盒子模型，设置元素的 height/width 属性指的是content部分的高/宽
- border-box：IE传统盒子模型。设置元素的height/width属性指的是`border + padding + content`       【`没有margin`】部分的高/宽

### 第43题：前端项目中为什么要初始化CSS样式？

因为浏览器的兼容问题，`不同浏览器对标签的默认值是不同的`，如果没有对浏览器的CSS初始化，会造成`相同页面在不同浏览器`的显示存在差异。

### 第44题：页面导入样式时，使用link和@import有什么区别？

1. 本身：     link属于HTML标签，而@import是css提供的；
2. 加载时： 页面被加载时，link会同时被加载，而@import引用的`css会等到页面被加载完再加载`；
3. 兼容性： @import只在IE5以上才能识别，而link是XHTML标签，`无兼容问题`；
4. 权重：     link方式的样式的`权重高于@import的权重`。
