## 带着问题看内容

1. 什么是垃圾回收机制?
2. 垃圾是怎样产生的?
3. 内存泄漏的场景有哪些？
4. 为什么要进行垃圾回收?
5. 垃圾回收是怎样进行的?
6. V8 引擎对垃圾回收进行了哪些优化?

## 如何检测内存泄漏

视频里的 - **检测内存变化方法**

1. 可使用 Chrome devTools Performance 来检测内存变化

   - 刷新页面，点击“GC”按钮

   - 点击“Record”按钮开始记录，然后操作页面
   - 操作结束，点击“GC”按钮，点击“结束”按钮，看分析结果

   代码参考 `memory-change.html`

2. 【Shift + Esc】任务管理器

## 内存泄漏的场景

**以 Vue 为例，有**

1. 组件内设置的全局变量【`window`】上的；
   ------ window.xx = null; 销毁
2. 组件内部设置的`定时器`【实时监测内的 setInterval】
   ------ 通过 clearInterval(id) 销毁；
3. 组件内注册的`全局事件`【echarts 内注册到 window 上的 resize】
   ------ window.removeEventListener('resize',fn) 销毁；
4. 事件总线【`发布订阅模式`】内订阅者【$on】订阅了事件后，退出前需要【$off】，否则会绑定在【调度中心内，不会删除】
5. ------ busEvent.$off(event,fn)
6. 变量销毁不了，一定就是内存泄漏吗？—— 不一定【闭包，就需要这个】

1.组件中有全局变量、函数的引用。组件销毁时要记得清空。

```js
export default {
  data() {
    return {
      nums: [10, 20, 30],
    };
  },
  mounted() {
    window.printNums = () => {
      console.log(this.nums);
    };
  },
  // beforeUnmount() {
  //     window.printNums = null
  // },
};
```

2.组件有全局定时器。组件销毁时要记得清除。

```js
export default {
  data() {
    return {
      // intervalId: 0,
      nums: [10, 20, 30],
    };
  },
  // methods: {
  //     printNums() {
  //         console.log(this.nums)
  //     }
  // },
  mounted() {
    setInterval(() => {
      console.log(this.nums);
    }, 200);

    // this.intervalId = setInterval(this.printNums, 200)
  },
  beforeUnmount() {
    // clearInterval(this.intervalId)
  },
};
```

3.组件中有全局事件的引用。组件销毁时记得解绑。

```js
export default {
  data() {
    return {
      nums: [10, 20, 30],
    };
  },
  // methods: {
  //     printNums() {
  //         console.log(this.nums)
  //     }
  // },
  mounted() {
    window.addEventListener("resize", () => {
      console.log(this.nums);
    });
    // window.addEventListener('reisze', this.printNums)
  },
  beforeUnmount() {
    // window.removeEventListener('reisze', this.printNums)
  },
};
```

4.组件中使用了自定义事件，销毁时要记得解绑。

```js
export default {
  data() {
    return {
      nums: [10, 20, 30],
    };
  },
  // methods: {
  //     printNums() {
  //         console.log(this.nums)
  //     }
  // },
  mounted() {
    event.on("event-key", () => {
      console.log(this.nums);
    });

    // event.on('event-key', this.printNums)
  },
  beforeUnmount() {
    // event.off('event-key', this.printNums)
  },
};
```

### 闭包是内存泄漏吗

先说我的结论【说法不一】：`不是`。

1. 内存泄漏主要体现在`泄漏`上，在`非自愿的、在不知情的`情况下才叫泄漏；
2. 但闭包就是为了让一个`活着的变量`在函数之外，这是闭包的特性；
3. 闭包中的`变量`是可控的，一般情况下`设计和使用`都是在可控范围内。

## [垃圾回收机制](https://juejin.cn/post/6981588276356317214)

### 一、引用计数

早起的垃圾回收算法，以“数据是否被引用”来判断要不要回收。

```js
// 对象被 a 引用
let a = {
  b: {
    x: 10,
  },
};

let a1 = a; // 又被 a1 引用
let a = 0; // 不再被 a 引用，但仍然被 a1 引用
let a1 = null; // 不再被 a1 引用

// 对象最终没有任何引用，会被回收
```

但这个算法有一个缺陷 —— 循环引用。例如

```js
function fn() {
  const obj1 = {};
  const obj2 = {};
  obj1.a = obj2;
  obj2.a = obj1; // 循环引用，无法回收 obj1 和 obj2
}
fn();
```

此前有一个很著名的例子。IE6、7 使用引用计数算法进行垃圾回收，常常因为循环引用导致 DOM 对象无法进行垃圾回收。
下面的例子，即便界面上删除了 div1 ，但在 JS 内存中它仍然存在，包括它的所有属性。但现代浏览器已经解决了这个问题。

```js
var div1
window.onload = function () {
    div1 = document.getElementById('div1')
    div1.aaa = div1
    div1.someBigData = { ... } // 一个体积很大的数据。
}
```

以上这个例子就是内存泄漏。即，**不希望它存在的，它却仍然存在**，这是不符合预期的。关键在于“泄漏”。

### 二、标记清除与标记整理

标记清除（Mark-Sweep），目前在 `JavaScript引擎` 里这种算法是最常用的，到目前为止的大多数浏览器的 `JavaScript引擎` 都在采用标记清除算法，只是各大浏览器厂商还对此算法进行了优化加工，且不同浏览器的 `JavaScript引擎` 在运行垃圾回收的频率上有所差异

就像它的名字一样，此算法分为 `标记` 和 `清除` 两个阶段，标记阶段即为所有活动对象做上标记，清除阶段则把没有标记（也就是非活动对象）销毁

你可能会疑惑怎么给变量加标记？其实有很多种办法，比如当变量进入执行环境时，反转某一位（通过一个二进制字符来表示标记），又或者可以维护进入环境变量和离开环境变量这样两个列表，可以自由的把变量从一个列表转移到另一个列表，当前还有很多其他办法。其实，怎样标记对我们来说并不重要，重要的是其策略

引擎在执行 GC（使用标记清除算法）时，需要从出发点去遍历内存中所有的对象去打标记，而这个出发点有很多，我们称之为一组 `根` 对象，而所谓的根对象，其实在浏览器环境中包括又不止于 `全局Window对象`、`文档DOM树` 等

整个标记清除算法大致过程就像下面这样

- 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为 0
- 然后从各个根对象开始遍历，把不是垃圾的节点改成 1
- 清理所有标记为 0 的垃圾，销毁并回收它们所占用的内存空间
- 最后，把所有内存中对象标记修改为 0，等待下一轮垃圾回收

**优点**

标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0 和 1）就可以为其标记，非常简单

**缺点**

标记清除算法有一个很大的缺点，就是在清除之后，剩余的对象内存位置是不变的，也会导致空闲内存空间是不连续的，出现了 `内存碎片`（如下图），并且由于剩余空闲内存不是一整块，它是由不同大小内存组成的内存列表，这就牵扯出了内存分配的问题

![img](D:\Sync\typora图片\12247ac3d8f249a5ab85b9b40ba1147btplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp)

假设我们新建对象分配内存时需要大小为 `size`，由于空闲内存是间断的、不连续的，则需要对空闲内存列表进行一次单向遍历找出大于等于 `size` 的块才能为其分配（如下图）

![img](D:\Sync\typora图片\fb5107f04a3249ce8d37ec7cc5fd9668tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp)

那如何找到合适的块呢？我们可以采取下面三种分配策略

- `First-fit`，找到大于等于 `size` 的块立即返回
- `Best-fit`，遍历整个空闲列表，返回大于等于 `size` 的最小分块
- `Worst-fit`，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 `size` 大小，并将该部分返回

这三种策略里面 `Worst-fit` 的空间利用率看起来是最合理，但实际上切分之后会造成更多的小块，形成内存碎片，所以不推荐使用，对于 `First-fit` 和 `Best-fit` 来说，考虑到分配的速度和效率 `First-fit` 是更为明智的选择

综上所述，标记清除算法或者说策略就有两个很明显的缺点

- **内存碎片化**，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
- **分配速度慢**，因为即便是使用 `First-fit` 策略，其操作仍是一个 `O(n)` 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢

**PS：标记清除算法的缺点补充**

归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了

而 **标记整理（Mark-Compact）算法** 就可以有效地解决，它的标记阶段和标记清除算法没有什么不同，只是标记结束后，标记整理算法会将活着的对象（即不需要清理的对象）向内存的一端移动，最后清理掉边界的内存（如下图）

![img](D:\Sync\typora图片\c04b0a5a40084e0ba4550500c57f2270tplv-k3u1fbpfcp-zoom-in-crop-mark3024000.webp)

### 三、V8 的优化 [分代式垃圾回收](https://juejin.cn/post/6981588276356317214#heading-6)

我们在上面也说过，现在大多数浏览器都是基于标记清除算法，V8 亦是，当然 V8 肯定也对其进行了一些优化加工处理，那接下来我们主要就来看 V8 中对垃圾回收机制的优化

试想一下，我们上面所说的垃圾清理算法在每次垃圾回收时都要检查内存中所有的对象，这样的话对于一些大、老、存活时间长的对象来说同新、小、存活时间短的对象一个频率的检查很不好，因为前者需要时间长并且不需要频繁进行清理，后者恰好相反，怎么优化这点呢？？？分代式就来了

#### 新老生代

V8 的垃圾回收策略主要基于分代式垃圾回收机制，V8 中将堆内存分为新生代和老生代两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收

新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 `1～8M` 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大

V8 整个堆内存的大小就等于新生代加上老生代的内存（如下图）

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/abae5b06648a40d2aaa453b5d8a83939~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

对于新老两块内存区域的垃圾回收，V8 采用了两个垃圾回收器来管控，我们暂且将管理新生代的垃圾回收器叫做新生代垃圾回收器，同样的，我们称管理老生代的垃圾回收器叫做老生代垃圾回收器好了

#### 新生代垃圾回收

新生代对象是通过一个名为 `Scavenge` 的算法进行垃圾回收，在 `Scavenge算法` 的具体实现中，主要采用了一种复制式的方法即 `Cheney算法` ，我们细细道来

`Cheney算法` 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 `使用区`，一个是处于闲置状态的空间我们称之为 `空闲区`，如下图所示

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa2d5ad1d89b4b7b919f20e4a5f8973a~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作

当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区

当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理

另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 `Scavenge` 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配

#### 老生代垃圾回收

相比于新生代，老生代的垃圾回收就比较容易理解了，上面我们说过，对于大多数占用空间大、存活时间长的对象会被分配到老生代里，因为老生代中的对象通常比较大，如果再如新生代一般分区然后复制来复制去就会非常耗时，从而导致回收执行效率不高，所以老生代垃圾回收器来管理其垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法了

首先是标记阶段，从一组根元素开始，递归遍历这组根元素，遍历过程中能到达的元素称为活动对象，没有到达的元素就可以判断为非活动对象

清除阶段老生代垃圾回收器会直接将非活动对象，也就是数据清理掉

前面我们也提过，标记清除算法在清除后会产生大量不连续的内存碎片，过多的碎片会导致大对象无法分配到足够的连续内存，而 V8 中就采用了我们上文中说的标记整理算法来解决这一问题来优化空间

#### 为什么需要分代式？

正如小标题，为什么需要分代式？这个机制有什么优点又解决了什么问题呢？

其实，它并不能说是解决了什么问题，可以说是一个优化点吧

分代式机制把一些新、小、存活时间短的对象作为新生代，采用一小块内存频率较高的快速清理，而一些大、老、存活时间长的对象作为老生代，使其很少接受检查，新老生代的回收机制及频率是不同的，可以说此机制的出现很大程度提高了垃圾回收机制的效率

### 优缺点总结

![垃圾回收对比](C:\Users\11653\Desktop\垃圾回收对比.png)

## [垃圾回收的使用场景优化](https://juejin.cn/post/6844903833387155464#heading-11)

### 一、数组 array 优化

将[]赋值给一个数组对象，是清空数组的捷径(例如： arr = [];),但是需要注意的是，这种方式又创建了一个新的空对象，并且将原来的数组对象变成了一小片内存垃圾！实际上，将数组长度赋值为 0（arr.length = 0）也能达到清空数组的目的，并且同时能实现数组重用，减少内存垃圾的产生。

```js
const arr = [1, 2, 3, 4];
console.log("浪里行舟");
arr.length = 0; // 可以直接让数字清空，而且数组类型不变。
// arr = []; 虽然让a变量成一个空数组,但是在堆上重新申请了一个空数组对象。
复制代码;
```

### 二、 对象尽量复用

对象尽量复用，尤其是在循环等地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为 null，尽快被垃圾回收掉。

```js
var t = {}; // 每次循环都会创建一个新对象。
for (var i = 0; i < 10; i++) {
  // var t = {};// 每次循环都会创建一个新对象。
  t.age = 19;
  t.name = "123";
  t.index = i;
  console.log(t);
}
t = null; //对象如果已经不用了，那就立即设置为null；等待垃圾回收。
复制代码;
```

### 三、在循环中的函数表达式，能复用最好放到循环外面。

```js
// 在循环中最好也别使用函数表达式。
for (var k = 0; k < 10; k++) {
  var t = function (a) {
    // 创建了10次  函数对象。
    console.log(a);
  };
  t(k);
}

// 推荐用法
function t(a) {
  console.log(a);
}
for (var k = 0; k < 10; k++) {
  t(k);
}
t = null;
```

### 四、使用 WekMap WekSet 【视频里的】

WeakMap WeakSet 弱引用，不会影响垃圾回收。

```js
// 函数执行完，obj 会被销毁，因为外面的 WeakMap 是“弱引用”，不算在内
const wMap = new WeakMap();
function fn() {
  const obj = {
    name: "zhangsan",
  };
  // 注意，WeakMap 专门做弱引用的，因此 WeakMap 只接受对象作为键名（`null`除外），不接受其他类型的值作为键名。其他的无意义
  wMap.set(obj, 100);
}
fn();
// 代码执行完毕之后，obj 会被销毁，wMap 中也不再存在。但我们无法第一时间看到效果。因为：
// 内存的垃圾回收机制，不是实时的，而且是 JS 代码控制不了的，因此这里不一定能直接看到效果。
```

```js
// 函数执行完，obj 会被销毁，因为外面的 WeakSet 是“弱引用”，不算在内
const wSet = new WeakSet();
function fn() {
  const obj = {
    name: "zhangsan",
  };
  wSet.add(obj); // 注意，WeakSet 就是为了做弱引用的，因此不能 add 值类型！！！无意义
}
fn();
```

wangEditor 多次销毁创建，测试内存泄漏。日常开发时可以参考这种方式
参考 examples/batch-destroy.html

## 参考

1. [「硬核 JS」你真的了解垃圾回收机制吗](https://juejin.cn/post/6981588276356317214)
   - 讲得很深
2. [「硬核 JS」你的程序中可能存在内存泄漏](https://juejin.cn/post/6984188410659340324)
   - [带 demo](https://juejin.cn/post/6984188410659340324#heading-11)
   - 带解析
3. [JavaScript 中的垃圾回收和内存泄漏](https://juejin.cn/post/6844903833387155464?share_token=430060ce-bf64-429e-b723-8f04f03c1ee2)
   - 含有使用场景优化
   - 不过在看到这个之前已经用上了
4. 2 周刷完 100 道前端优质面试真题 - 视频课
