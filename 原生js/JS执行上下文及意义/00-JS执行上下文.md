

## 先抛出问题

下边的能够解释哪

## EC(Execution Context)总结-意义

### 能够解释

1. 闭包【闭包保存的变量在堆内存中，外部函数调用，创建函数执行上下文，内部有词法环境，保存着函数内部数据与内部函数】；
2. 作用域链【词法环境中】；
3. 函数的静态/词法作用域【函数在声明时就将创建了堆内存，保存其函数体与父级作用域】；
4. let的TDZ【词法环境优先于变量环境】；
5. 函数声明和函数表达式区别；
6. this指向；

总结下：

1. 变量初始化
   - let的TDZ；【词法环境优先于变量环境】
   - 函数声明和函数表达式区别；
2. 声明变量活动范围
   - 闭包；【闭包的原始值也在堆内存中】
   - 函数的静态/词法作用域；
   - 作用域链；
   - this指向

### 能够回答

**链表的使用例子**

在这就算是【函数套函数时候，一个内存地址指向另一个】

## 前置知识

此为从ES3-ES5中抽离出的需要了解的知识

需要了解两个概念：

1. 调用栈；
2. 执行上下文。

### [调用栈 Call Stack](https://developer.mozilla.org/zh-CN/docs/Glossary/Call_stack) 

`调用栈又叫执行上下文栈、执行栈`，调用栈是解释器（比如浏览器中的 JavaScript 解释器）`追踪函数执行流的一种机制`。当执行环境中调用了多个[函数](https://developer.mozilla.org/zh-CN/docs/Glossary/Function)时，通过这种机制，我们能够追踪到哪个函数正在执行，执行的函数体中又调用了哪个函数。

- 每`调用`一个函数，解释器就会把`该函数添加进调用栈并开始执行`；
- 正在调用栈中执行的函数还调用了其它函数，那么新函数也将会被添加进调用栈，一旦这个函数被调用，便会立即执行；
- 当前函数执行完毕后，解释器将其`弹出调用栈`，继续执行当前执行环境下的剩余的代码；【关联尾递归】
- 当分配的调用栈空间被占满时，会引发“堆栈溢出”错误【常见的 Maximum call stack size exceeded】，引发栈溢出的栈大小由于浏览器的厂商、版本各不相同。

### 执行上下文

执行上下文是一个抽象的概念【`可以理解为一个对象`】，是`JS代码执行的环境`，即JS代码总是在执行上下文中运行。

**JavaScript 中有三种执行上下文类型**

1. **全局执行上下文** 
   - 默认上下文，`一个程序中只有一个GEC`(Global Execution Context)；
   - 创建一个全局的 window 对象浏览器的情况下），并且设置 `this` 的值等于这个全局对象。
2. **函数执行上下文**
   - `函数被调用时`创建的新的上下文；【`思考：没调用时函数在哪？`】
   - 当一个新的执行上下文被创建，它会按添加到`调用栈`中的顺序依次执行；
3. **Eval 函数执行上下文**
   - 执行在 `eval` 函数内部的代码的执行上下文；
   - 由于不经常使用，此处不做讨论。

### ES5 ES3的EC区别

ES3和ES5之后的执行上下文区别在于`执行上下文这个'对象'包括的内容不同`，而这`决定了`JS代码运行的特征有所不同。		

### 执行上下文意义

建议先看完文章，最后自问下。

1. 作用域链，
2. 控制变量活动范围
3. let const 于var区别

### 文章看的顺序

1. 2022-02 微信公众号[JS 的执行过程](https://mp.weixin.qq.com/s/Ya54qCLwYpWpIQzmqQgAQg)
   - 只有ES3，但是是讲得最全面的，将其中对应概念换成ES5的即可
2. 2018-09[[译] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)
   - ES5
3. 2020-05 [面试官：说说执行上下文吧](https://juejin.cn/post/6844904158957404167)
   - `很全`，ES3、ES5都写了
   - `但是`没有说【执行上下文中this绑定、词法环境、变量环境】的意义，只提到了调用栈与尾递归

## ES5执行上下文

参考文章已经讲得很好了

### TDZ案例

```
// TDZ测试：
var temp = 1;

if (true) {
  // temp = "a"; // ReferenceError
  let temp;
  console.log(temp);
}

解析：【全局执行上下文内】
GlobalExectionContext = {
  ThisBinding: "<Global Object>",

  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      temp: "< uninitialized >",
    },
    outer: "<null>",
  },

  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      // 在这里绑定标识符
      temp: undefined,
    },
    outer: "<null>",
  },
};
```

## ES3

参考文章已经讲得很好了

## 参考

1. 2022-02 微信公众号[JS 的执行过程](https://mp.weixin.qq.com/s/Ya54qCLwYpWpIQzmqQgAQg)

   - 只有ES3，但是是讲得最全面的，将其中对应概念换成ES5的即可

2. 2018-09[[译] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)

   - ES5

3. 2020-05 [面试官：说说执行上下文吧](https://juejin.cn/post/6844904158957404167)

   - `很全`，ES3、ES5都写了
   - `但是`没有说【执行上下文中this绑定、词法环境、变量环境】的意义，只提到了调用栈与尾递归

   

